<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Xduce: Transducers for JavaScript</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro">
  <link rel="stylesheet" href="../css/tomorrow-night-eighties.css">
  <link rel="stylesheet" href="../css/site.css">
</head>
<body>
  <header></header>
  <section id="content">

    <article>
      <section id="intro">
        <p><em>
          This page could easily be regarded as optional. There isn't anything in here that will tell you how
          to use Xduce. But if you're interested in why you're using Xduce, or what's going on under the
          covers, then you might find this page satisfying. I found it satisfying to write it.
        </em></p>
      </section>
      <section id="transducer">
        <h3>Transducer? What's that?</h3>
        <p>
          That's a great question. For the moment, we're going to define it as "a different way to do transformation of
          collections". To answer it further, we're going to have to go a little into the same old way of doing
          transformation of collections and see why we might want to do it differently.
        </p>
        <p>
          Maybe the quintessential collection transformer is <code>map</code>, so let's start our look there. In
          JavaScript, it is a method on the <code>Array</code> object, and it's normally invoked like this:
        </p>
        <pre><code class="javascript">
          const arr = [1, 2, 3, 4, 5];
          const fn = x => x + 1;
          const result = arr.map(fn);
          // result = [2, 3, 4, 5, 6]
        </code></pre>
        <p>
          So what <code>map</code> is doing here is 1) breaking apart a collection (in this case, <code>arr</code>),
          2) feeding the values from the collection to a function (<code>fn</code>) to get new values, and 3) putting
          those values together into a new collection (<code>result</code>). This is great. It's very useful, and
          <code>map</code> gets used all the time, whether overtly or behind the scenes in a library somewhere.
        </p>
        <p>
          But is it really so great? A good programmer knows that a function should do one thing and do it well.
          <code>map</code> is doing <em>three</em> things. A good programmer knows that a function should stick to what
          it's concerned with. <code>map</code> should be concerned with mapping values to new values by passing them
          to a function. Why is it dealing with breaking apart a collection? That doesn't have anything to do with
          mapping. Neither does putting a new collection together. This seems like a problem.
        </p>
        <p>
          In fact, it's a bigger problem than at first glance, because there's something else about <code>map</code>
          that everyone knows but no one really talks about, because it's the way it's always been done. This
          <code>map</code> function <em>only</em> allows you to vary the way values are mapped, by passing a different
          mapping function. It does not allow you to vary the way the input is taken apart, and it doesn't allow you to
          vary the way the output is put together. Those parts are <em>hard-coded</em> inside the <code>map</code>
          function, where you can't access them. And they mean that this <code>map</code> that <code>Array</code>
          offers can only take an array as input, and it can only provide an array as output. This also seems like a
          problem.
        </p>
        <p>
          So how do we solve these problems? Well...transducers.
        </p>
      </section>

      <section id="steps">
        <h2>Iteration, transformation, reduction</h2>
        <p>
          We have names for each of these three steps of collection manipulation. The part where the input collection
          is broken into pieces is called <em>iteration</em>. The part where the pieces are changed is called
          <em>transformation</em>. And the part where the transformed pieces are put back together again is called
          <em>reduction</em>.
        </p>
        <p>
          The basic problem that we have with traditional collection processing is that only the transformation part is
          truly general and decoupled. In calling <code>arr.map(fn)</code>, <code>fn</code> can really be any function
          at all. <code>map</code> doesn't have to care at all what kind of transformation is being done. This is the
          way we'd like to have the iteration and reduction steps handled, too.
        </p>
        <p>
          That, really, gets to the heart of what a transducer is. A transducer is a function that can transform data
          in some way, just like traditional <code>map</code>, but that <em>doesn't care</em> what kind of collection
          the data comes from or is put back into. A <code>map</code> transducer truly cares only about mapping. It
          doesn't care about what kind of collection they came from, and it doesn't care what kind of collection the
          mapped values are put into. Which means a <code>map</code> transducer can work with arrays, objects,
          strings, generators, channels, streams, immutable lists, or any other kind of collection-like data construct
          you can imagine. It doesn't even care if the input and output collections are of the same type. It could take
          data from an array and send it out as a string, or it could take data from an object and result in a
          generator.
        </p>
        <p>
          How does it do that? Well, let's walk through moving from traditional <code>map</code> to transducer
          <code>map</code>, and we'll start by trying to generalize the first step: iteration.
        </p>
      </section>

      <section id="iteration">
        <h2>Generalized iteration</h2>
        <p>
          In fact, this is really the easy part. JavaScript already does it for us, at least as of ES2015. That's when
          <em>protocols</em> entered the language, and it so happens that two of the first batch of protocols to be
          added were the <em>iteration</em> protocols. Sounds promising.
        </p>
        <p>
          If you're interested in the gory details,
          <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">read about
          them on the Mozilla Developer Network</a>. The gist is that if a collection can conform to these protocols,
          it gains the ability to be used in one of the new ES2015 constructs, the <code>for...of</code> loop.
        </p>
        <p>
          The <code>for...of</code> loop breaks apart a collection into its components and runs through the loop one
          time for each component. Sound familiar? It's iteration. And the iteration protocols are built-in for
          JavaScript arrays, strings, and generators. They can also be defined by programmers, and several third-party
          collection libraries implement them. Let's take a look at some examples.
        </p>
        <aside>
          <p>
            In all of the examples on this page, I will be using the variable name <code>xs</code> to refer to a
            collection. This is pronounced "exes" and is literally meant to be the plural of <code>x</code>, which is
            a single element in the collection. This is a common convention in functional programming.
          </p>
        </aside>
        <pre><code class="javascript">
          const xs = [1, 2, 3, 4, 5];
          const result = [];
          for (const x of xs) {
            result.push(x + 1);
          }
          // result = [2, 3, 4, 5, 6];
        </code></pre>
        <p>
          That's mapping an array using <code>for...of</code>. What about other input collections, like strings?
        </p>
        <pre><code class="javascript">
          const xs = 'hello';
          const result = [];
          for (const x of xs) {
            result.push(x.toUpperCase());
          }
          // result = ['H', 'E', 'L', 'L', 'O']
        </code></pre>
        <p>
          Does it really work with third-party collections?
        </p>
        <pre><code class="javascript">
          const xs = Immutable.List.of(1, 2, 3, 4, 5);
          const result = [];
          for (const x of xs) {
            result.push(x + 1);
          }
          // result = [2, 3, 4, 5, 6];
        </code></pre>
        <aside>
          <p>
            This last one uses a <code>List</code> from
            <a href="https://facebook.github.io/immutable-js/">Immutable</a>, a third-party library of immutable
            data structures that does, in fact, implement the iterator protocols.
          </p>
        </aside>
        <p>
          So the same construct is used to break down any collection (at least, any collection that implements the
          iteration protocols, which we'll assume from now on even without saying it) into its pieces. In fact, it's so
          regular that we can abstract that away and make it a function that works with any kind of input collection.
        </p>
        <pre><code class="javascript">
          function map2(xs, fn) {
            const result = [];
            for (const x of xs) {
              result.push(fn(x));
            }
            return result;
          }

          map2([1, 2, 3, 4, 5], x => x + 1);                  // [2, 3, 4, 5, 6]
          map2('hello', x => x.toUpperCase());                // ['H', 'E', 'L', 'L', 'O']
          map2(Immutable.List.of(1, 2, 3, 4, 5), x => x + 1); // [2, 3, 4, 5, 6]
        </code></pre>
        <p>
          So we've already written a function that can map <em>any</em> kind of input collection, but it always returns
          an array. This is because the reduction step amounts to pushing the transformed result into an array. We could
          change this to anything we want to - string concatentation, creating a new immutable list, yielding out of a
          generator - but whatever we change it to, it'll still be hard-coded. We haven't yet made our reduction
          generalized. Let's look at that next.
        </p>
      </section>

      <section id="reduction">
        <h2>Generalized Reduction</h2>
        <p>
          Reduction is a pretty familiar concept to a lot of programmers as well; in fact, the same <code>Array</code>
          object where <code>map</code> is defined also defines a <code>reduce</code> function. Let's take a look at it
          in action.
        </p>
        <pre><code class="javascript">
          const arr = [1, 2, 3, 4, 5];
          const fn = x => x + 1;
          const result = arr.reduce((acc, x) => {
            acc.push(fn(x));
            return acc;
          }, []);
          // result = [2, 3, 4, 5, 6]
        </code></pre>
        <p>
          What this code is doing is...well, it's exactly the same as the first example on this page. It's
          <code>map</code>, defined in terms of <code>reduce</code>. (Interestingly, you can define pretty much any
          collection manipulation function in terms of <code>reduce</code>, but that's a subject for another time.)
        </p>
        <p>
          The <code>reduce</code> function itself works with three pieces of information: the input collection (in this
          case, <code>arr</code>), a <em>reducer function</em>, and an <em>initial value</em>. The reducer function is
          what actually builds the output collection. It takes two arguments: the current, unfinished output (often
          called the <em>accumulator</em>, which is why I name it <code>acc</code>) and the next element of the input
          collection. Its job is to process that element however it needs to and join it with the accumulator to create
          an updated accumulator. Once all of the elements have been processed, that final accumulator is what's
          returned from the <code>reduce</code> function.
        </p>
        <p>
          The initial value is there because, on the very first invocation of the reducer function, there <em>is no</em>
          accumulator. After all, the function hasn't been run yet to produce one. So on that first go, the initial
          value is sent to the reducer function as the accumulator.
        </p>
        <p>
          Thing is, if you squint just right, you can see both of these new ideas - a reducer function and an initial
          value - in our <code>map2</code> function from the last section. Let's look at the function again.
        </p>
        <pre><code class="javascript">
          function map2(xs, fn) {
            const result = [];
            for (const x of xs) {
              result.push(fn(x));
            }
            return result;
          }
        </code></pre>
        <p>
          That value that's assigned to <code>result</code> sure does look like an initial value, and the body of the
          <code>for...of</code> loop looks an awful lot like the reduction function. Now that we've identified these
          aspects that are playing a part in reduction, let's see if we can abstract them out.
        </p>
        <pre><code class="javascript">
          function map3(xs, fn, init, step) {
            let acc = init;
            for (const x of xs) {
              acc = step(acc, fn(x));
            }
            return acc;
          }
        </code></pre>
        <p>
          That looks pretty good. There is nothing hard-coded at all; the reducer function (called <code>step</code>,
          since it runs once for every step through the loop), the initial value, the transformation function, and the
          collection are all passed in as arguments. The <code>for...of</code> loop handles the iteration. Inside of
          it, the <code>step</code> function is passed the current accumulator (which is set as the initial value the
          first time through) and the transformed next value in the collection, and it returns a new accumulator. When
          the iteration is complete, the last value of the accumulator is returned as the result. This sounds
          <em>exactly</em> like our <code>reduce</code>-driven mapping above.
        </p>
        <p>
          Let's try it out.
        </p>
        <pre><code class="javascript">
          function arrayReducer(acc, x) {
            acc.push(x);
            return x;
          }
          function stringReducer(acc, x) {
            return acc + x;
          }
          function listReducer(acc, x) {
            return acc.push(x);
          }

          map3([1, 2, 3, 4, 5], x => x + 1, [], arrayReducer);
          // -> [2, 3, 4, 5, 6]
          map3('hello', x => x + x, '', stringReducer);
          // -> 'hheelllloo'
          const List = Immutable.List;
          map3(List.of(1, 2, 3, 4, 5), x => x + 1, List().asMutable(), listReducer);
          // -> List(2, 3, 4, 5, 6)
        </code></pre>
        <p>
          Great! <code>map3</code> is a <em>map transducer</em>. It <em>only</em> deals with transformation; the
          iteration (via the iteration protocols on the input collection) and the reduction (via the step function and
          initial value that we pass to it) are handled by other code that's meant to handle them. What's more, as
          long as the input collection implements those iterator protocols and as long as we pass in an appropriate
          step function and initial value, <em>this same transducer will accept any kind of input collection and
          produce any kind of output collection</em>.
        </p>
        <p>
          So now we know what a transducer is. <strong>It's what's left after you take all of the things out of a
          collection manipulation function that don't belong there in the first place.</strong>
        </p>
      </section>

      <section id="result">
        <h2>But...but...but...</h2>
        <p>
          So we have a transducer! Well, yes, we do in theory, but there are still a couple problems with it. In fact,
          I'm not sure I would consider the benefits of using a transducer worth the downsides of the implementation
          that we've spent all this time developing.
        </p>
        <p>
          We've covered what transducers are pretty well, but now we're going to go beyond the theory a bit to discuss
          how to make them nicer to use. After all, it wouldn't do much good to take you all the way through this just
          to get to something that you turn your nose up at.
        </p>
        <p>
          Alright then. The first problem that I can see is that Immutable list example. The initial value is
          `List().asMutable()`. Maybe you aren't familiar with Immutable, but it should be pretty clear to anyone that
          what we have here is <em>not</em> an immutable list.
        </p>
        <p>
          Which is fine. After all, immutable lists are...well, immutable. You can't add anything to them. So if you're
          starting with an empty immutable list, you're <em>always</em> going to have an empty immutable list, no
          matter how many times you feed it to the step function. We use a mutable list here because we are going to
          need to add things to it.
        </p>
        <aside>
          <p>
            It <em>is</em> true that we could supply an empty immutable list and then have the step function make a new
            immutable list each time. Something like this:
          </p>
          <pre><code class="javascript">
            function listReducer(acc, x) {
              return Immutable.List.fromJS(acc.toArray().concat([x]));
            }
            map3(List.of(1, 2, 3, 4, 5), x => x + 1, Immutable.List(), listReducer);
            // -> List(2, 3, 4, 5, 6)
          </code></pre>
          <p>
            But this is far from ideal. Not only is the implementation of the list reducer function much more complex,
            it's going to be hopelessly inefficient, creating a new list and throwing it away for every single element
            in the input collection. List-based languages where immutable lists are common often allow programming
            like this because of optimizations that take away the need for new lists to be created, but JavaScript is
            not one of those languages.
          </p>
        </aside>
        <p>
          But if we're using a mutable list as an initial value, we're going to get an immutable list back as a final
          value. How can we solve this problem, allowing us to start with a mutable list but end with an immutable one?
          The answer is: we pass our transducer just one. More. Function.
        </p>
        <pre><code class="javascript">
          function map4(xs, fn, init, step, result) {
            let acc = init;
            for (const x of xs) {
              acc = step(acc, fn(x));
            }
            return result(acc);
          }

          const xs = Immutable.List.of(1, 2, 3, 4, 5);
          const fn = x => x + 1;
          const init = Immutable.List().asMutable();
          const step = (acc, x) => acc.push(x);
          const result = (acc) => acc.asImmutable();

          map4(xs, fn, init, step, result);
          // -> List(2, 3, 4, 5, 6), but this time immutable
        </code></pre>
        <p>
          The only change that has been made here is the addition of the <code>result</code> function. This is called
          on the final value of the accumulator, allowing one last chance to change that final collection before it's
          released into the wild. We pass it a function that turns a mutable list into an immutable one (provided, of
          course, by Immutable itself), and voila, our transducer can take a mutable initial value and return an
          immutable result.
        </p>
        <p>
          Most collections won't actually want to change that final accumulator before it's returned. For them, we
          should pass the transducer a <code>result</code> of <code>x => x</code>, a function that just returns its
          argument. In fact, that could be the default value for the <code>result</code> parameter, which I didn't
          actually do just because it made it a little harder to understand what we were doing.
        </p>
        <p>
          Okay! But really, <em>five</em> parameters for every transducer call? That's a lot worse than the two
          parameters that we have to send to a normal <code>map</code> function (collection and function). Worse yet,
          if you keep using the same kind of collection, three of them  are always going to be the same, no matter
          what. That seems bad. let's call that problem number 2, and let's solve it now.
        </p>
      </section>

      <section id="protocols">
        <h2>Remember protocols?</h2>
        <p>
          You might remember that back in the section about generalized iteration, I mentioned that ES2015 added
          protocols and made built-in protocols for iteration so that any kind of object could call itself iterable.
          You may have also noticed that once we took care of that, we never really had to think about <em>how</em>
          to iterate over a collection again. We didn't have to pass in a function as a parameter to instruct our
          various <code>map#</code> transducers on how to iterate. We just used a <code>for...of</code> loop and knew
          that the iteration protocols would handle it.
        </p>
        <p>
          So how about reduction protocols? Well, there aren't any built-in reduction protocols. But that doesn't mean
          that we can't make our own to use with transducers.
        </p>
        <p>
          Now, a protocol is really just an agreement that everyone is going to use a property of some agreed-upon
          name to do something. It's very much akin to an interface in class-based OO languages. So all that we're
          going to do is say that in order to satisfy our reduction protocols, a collection needs to implement three
          functions: one that provides an initial value of the collection, one that says how to add a value to the
          collection one step at a time, and one that says what to do with that collection once it's all built up. For
          the sake of ease, let's name these functions <code>init</code>, <code>step</code>, and <code>result</code>.
          If that seems familiar...well, it should be.
        </p>
        <p>
          If our <code>map</code> transducer knows that it's going to look on the collection object for these functions
          rather than having them passed in, it's pretty easy for it to call them.
        </p>
        <pre><code class="javascript">
          function map5(xs, fn) {
            let acc = xs.init();
            for (const x of xs) {
              acc = xs.step(acc, fn(x));
            }
            return xs.result(acc);
          }
        </code></pre>
        <p>
          The <em>only change</em> from our last transducer is that instead of calling functions that were passed to
          it, like in <code>map4</code>, <code>map5</code> finds those functions <em>on the input collection</em> and
          calls them from there. Now all anyone has to do to make their collection usable with each and every
          transducer that we write is to add those functions to their collection objects.
        </p>
        <pre><code class="javascript">
          const List = Immutable.List;
          List.prototype.init = () => List().asMutable();
          List.prototype.step = (acc, x) => acc.push(x);
          List.prototype.result = (acc) => acc.asImmutable();

          map5(List.of(1, 2, 3, 4, 5), x => x + 1);
          // -> List(2, 3, 4, 5, 6)
        </code></pre>
        <p>
          We can call any other transducer the same way, without having to re-define those three protocols. Once
          they're set, that's all you need. It's a one-shot deal.
        </p>
        <aside>
          <p>
            If you cringed a little inside at that last example, then good for you! Yes, it's a really bad idea to
            just go adding properties to other objects willy-nilly like that. What if <code>Immutable.List</code>
            already <em>had</em> a property named <code>init</code>? What if it doesn't right now, but adds one in the
            future?
          </p>
          <p>
            The best way to fix that is to use <em>symbols</em> for the protocol property names. Symbols are guaranteed
            to be unique, so there's no way you can use one to accidentally overwrite another property. To pull off
            transducers as we're doing here, you have to make sure that the exact same symbol is being used by the
            <code>map5</code> function as is being used to add the protocol properties.
          </p>
          <pre><code class="javascript">
            const init = Symbol();
            const step = Symbol();
            const result = Symbol();

            function map6(xs, fn) {
              const acc = xs[init]();
              for (const x of xs) {
                acc = xs[step](acc, fn(x));
              }
              return xs[result](acc);
            }

            const List = Immutable.List();
            List.prototype[init] = () => List().asMutable();
            List.prototype[step] = (acc, x) => acc.push(x);
            List.prototype[result] = (acc) => acc.asImmutable();

            map6(List.of(1, 2, 3, 4, 5), x => x + 1);
            // -> List(2, 3, 4, 5, 6)
          </code></pre>
          <p>
            Problem solved. We are guaranteed to not have overwritten anything on <code>Immutable.List</code>, and
            there's no way that someone could come along later and accidentally overwrite our protocols because there's
            no way for them to <em>accidentally</em> use the same property name.
          </p>
        </aside>
      </section>

      <section id="conclusion">
        <h3>Some final thoughts</h3>
        <p>
          We came a long way, considering that we started with a regular map function. We removed its responsibility
          for iteration and reduction, we gave it a way to transform the final output, and we made it so that it could
          read the instructions for both iterating <em>and</em> reducing from the collection object rather than having
          to be told explicitly by passing functions. By the time we were done, we had a pretty solid little map
          transducer, along with the knowledge necessary to make other transducers (filter, take, flatten, etc.).
        </p>
        <p>
          Of course, there's more that we could do to improve our map transducer.
        </p>
        <ul>
          <li>It isn't composable</li>
          <li>It can't have different input and output collection types</li>
          <li>It can't make a generator as output</li>
          <li>It still calls the iterator and reducer, and one could argue that it shouldn't even have <em>that</em>
          responsibility</li>
        </ul>
        <p>
          But those are details, and all we were trying to do here is understand transducers in general. Besides,
          Xduce does all of these things and plenty more, so you really don't have to try to do them unless you're
          into that kind of thing.
        </p>
      </section>
    </article>

    <nav class="main"></nav>
    <nav class="aux"></nav>
  </section>
  <footer></footer>

  <script src="../js/highlight.pack.js"></script>
  <script src="../js/highlightjs-line-numbers.min.js"></script>
  <script src="../js/layout.js"></script>
  <script src="js/theory.js"></script>
</body>
</html>
