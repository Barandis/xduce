<nav>
  <ul>
    <li><a href="#manual/about/features" title="Xduce features"><span class="fa fa-caret-left"></span></a></li>
    <li><a href="#manual/main" title="Table of contents"><span class="fa fa-caret-up"></span></a></li>
    <li><a href="#manual/setup/commonjs" title="CommonJS setup"><span class="fa fa-caret-right"></a></li>
  </ul>
</nav>

<section>
  <h1>Transducer theory</h1>
  <p><em>
    This page could easily be regarded as optional. There isn't anything in here that will tell you how
    to use xduce. But if you're interested in why you're using xduce, or what's going on under the
    covers, then you might find this page satisfying. I found it satisfying to write it.
  </em></p>
  <p><em>
    Also, it is </em>long<em>. There is a lot to explain, and I assume no knowledge about the subject matter, so I
    explain it thoroughly. There are even explanations of why some things </em>don't<em> work.
  </em></p>
</section>

<section>
  <h2>Transducer? What's that?</h2>
  <p>
    That's a great question. But it's a difficult one to answer without some background. Suffice it for the
    moment to say that transducers provide a different way to transform collections. In order to figure out
    what's so different and why that difference is good, we're going to start with a traditional list function.
    We'll learn a bit about it, and then we'll see what we need to do to morph it into a transducer and duscuss
    why those changes are good.
  </p>
  <aside>
    <p>
      I'm not sure that there's a well-established word for "those composable functions that exist in functional
      programming languages that let you manipulate the elements of a collection to produce a new collection".
      For the purpose of this page I'm going to just call them <strong>list functions</strong>, which isn't
      exactly right but also isn't exactly wrong.
    </p>
    <p>
      These functions came to prominence in list-based functional programming languages, but they've  long since
      been taken into many languages &mdash; like JavaScript &mdash; that are <em>not</em> list based.
      Nevertheless, there are problems with just about every other name I could give them, so we'll just agree
      that "list functions" can operate on collections that aren't lists and go with it.
    </p>
    <p>
      I'm not satisfied with "list function" but until someone comes up with something better, that's what
      I'll call them.
    </p>
  </aside>
  <p>
    Maybe the quintessential list function is <code>map</code>, so let's start our look there. In JavaScript,
    there is a function property named <code>map</code> on the <code>Array</code> object, and it's normally
    invoked like this:
  </p>
  <pre><code class="javascript">
    [1, 2, 3, 4, 5].map(x => x + 1);
    // -> [2, 3, 4, 5, 6]
  </code></pre>
  <p>
    So what <code>map</code> is doing here is 1) breaking apart a collection (in this case,
    <code>[1, 2, 3, 4, 5]</code>), 2) feeding the values from the collection to a function
    (<code>x => x + 1</code>) to get new values, and 3) putting those values together into a new collection
    (which turns out to be <code>[2, 3, 4, 5, 6]</code>). This is great. It's very useful, and <code>map</code>
    gets used all the time, whether overtly or behind the scenes in a library somewhere.
  </p>
  <p>
    But is it really so great? We have a couple of ideas in programming called the <strong>single responsibility
    principle</strong> and <strong>loose coupling</strong>. The former suggests that any software unit (like a
    module, class, or function) should be responsible for exactly one concern. The latter suggests that it's best
    if any particular unit knows as little as possible about other units. These are good principles because they
    make it much more likely that software produced with them in mind is modular and maintainable.
  </p>
  <p>
    <code>map</code>, as well as just about every other list function, violates both of these principles. It
    <em>should</em> have a single concern: mapping. Yet it also concerns itself with breaking a list apart and
    putting it back together, things that have nothing to do with mapping. And because it implements that
    breaking apart and putting back together without allowing for any customization, it's inextricably linked to
    arrays, which breaks loose coupling.
  </p>
  <aside>
    <p>
      In fairness, languages with typeclasses or generics (JavaScript is not one of these) do better with loose
      coupling on list functions, though they still violate single responsibility.
    </p>
  </aside>
  <p>
    As if that wasn't enough, it's very important that list functions be <strong>composable</strong>, meaning
    that they should be able to be chained together to accomplish more complex manipulations. And while list
    functions do in fact tend to be composable, they do it in a highly inefficient way.
  </p>
  <p>
    Let's take a moment to summarize the issues with <code>map</code> and, by extension, all of its list function
    brethren.
  </p>
  <ol>
    <li>
      It violates the single-responsibility principle by deconstructing the input array and constructing a new
      output array, when it really should only be doing mapping.
    </li>
    <li>
      It violates loose coupling by tying itself directly to the array, disallowing working with any other data
      structure.
    </li>
    <li>
      It composes, but in an inefficient way (I'll describe what's inefficient about <code>map</code>'s
      composition a little later).
    </li>
  </ol>
  <p>
    Having described all that baggage, let's see now what we can do to <code>map</code> to make these problems
    go away. We will do that by slowly morphing the <code>map</code> list function into a <code>map</code>
    <strong>transducer</strong>, which doesn't suffer from tight coupling, multiple responsibilities, or
    inefficient composition. Along the way, we'll learn exactly what a transducer is and how it's different from
    a list function.
  </p>
  <aside>
    <p>
      You're welcome to trust that the code in the examples throughout this page is correct and that you
      understand it perfectly just by reading it. If you don't feel so confident in either of those premises,
      then feel free to type it directly into a browser console (hit F12 in Chrome, for instance, which is what I
      did when I was writing this). If you have Node.js installed, you can also run all of this code in the REPL.
    </p>
    <p>
      The code is written to be usable by typing it all in from beginning to end, which is why you're bound to see a
      lot of <code>let</code>s where there might normally be <code>const</code>s.
    </p>
    <p>
      Which reminds me, it's all ES2015. If you're typing this into Internet Explorer's console, do not expect
      good results.
    </p>
  </aside>
</section>

<section>
  <h2>Iteration, transformation, reduction</h2>
  <p>
    We've observed that <code>map</code> is doing three things. In fact, we have names for these three things.
    The part where the input collection is broken into pieces is called <strong>iteration</strong>. The part
    where the pieces are changed is called <strong>transformation</strong>. And the part where the transformed
    pieces are put back together again is called <strong>reduction</strong>.
  </p>
  <p>
    With <code>map</code> &mdash; a function that <em>should</em> just be doing transformation but is also doing
    iteration and reduction &mdash; the programmer only has control over the transformation step. Any function
    at all can be passed to <code>map</code>, and <code>map</code> will duly pass all elements into this mapping
    function and collect its return values for the output collection. The iteration and reduction are hard-coded.
    We would definitely like to get rid of this restriction, not only because the hard-coding is the worst kind
    of tight coupling, but also because if we can loosely couple these two steps then it's easy to move
    responsibility for them somewhere else.
  </p>
  <p>
    But enough talk. We want to generalize the iteration and reduction that <code>map</code> is doing. Let's see
    how we can go about that, starting with iteration.
  </p>
</section>

<section>
  <h2>Generalized iteration</h2>
  <p>
    In fact, this is really the easy part. JavaScript already does it for us, at least as of ES2015. That's when
    <strong>protocols</strong> entered the language, and it so happens that two of the first batch of protocols
    to be added were the <em>iteration</em> protocols. Sounds promising.
  </p>
  <p>
    If you're interested in the gory details,
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">read about
    them on the Mozilla Developer Network</a>. The gist is that if a collection can conform to these protocols,
    it gains the ability to be used in one of the new ES2015 constructs, the <code>for...of</code> loop.
  </p>
  <p>
    The <code>for...of</code> loop breaks apart a collection into its components and runs through the loop one
    time for each component. Sound familiar? It's iteration. And the iteration protocols are built-in for
    JavaScript arrays, strings, and generators. They can also be defined by programmers, and several third-party
    collection libraries implement them. Let's take a look at some examples.
  </p>
  <aside>
    <p>
      In all of the examples on this page, I will be using the variable name <code>xs</code> to refer to a
      collection. This is pronounced "exes" and is literally meant to be the plural of <code>x</code>, which is
      a single element in the collection. This is a common convention in functional programming.
    </p>
  </aside>
  <pre><code class="javascript">
    let xs = [1, 2, 3, 4, 5];
    let result = [];
    for (const x of xs) {
      result.push(x + 1);
    }
    result;
    // -> [2, 3, 4, 5, 6]
  </code></pre>
  <p>
    That's mapping an array using <code>for...of</code>. What about other input collections, like strings?
  </p>
  <pre><code class="javascript">
    xs = 'hello';
    result = [];
    for (const x of xs) {
      result.push(x.toUpperCase());
    }
    result;
    // -> ["H", "E", "L", "L", "O"]
  </code></pre>
  <p>
    This will work for any collection with the iterator protocols implemented, and a good example of a collection
    like that is the <code>List</code> from <a href="https://facebook.github.io/immutable-js/">Immutable</a>, a
    third-party library of immutable data structures. If you want to be certain, you can type the following code
    into the console after making sure that Immutable is loaded into the page you're viewing in the browser. This
    will not work if you haven't loaded a page with Immutable in it, but if you don't have one, you can just skip
    it and trust that this works.
  </p>
  <pre><code class="javascript">
    xs = Immutable.List.of(1, 2, 3, 4, 5);
    result = [];
    for (const x of xs) {
      result.push(x + 1);
    }
    result;
    // -> [2, 3, 4, 5, 6];
  </code></pre>
  <p>
    So the same construct is used to break down any collection (at least, any collection that implements the
    iteration protocols, which we'll assume from now on even without saying it) into its pieces. In fact, it's so
    regular that we can abstract that away and make it a function that works with any kind of input collection.
  </p>
  <pre><code class="javascript">
    function map1(xs, fn) {
      const result = [];
      for (const x of xs) {
        result.push(fn(x));
      }
      return result;
    }

    map1([1, 2, 3, 4, 5], x => x + 1);
    // -> [2, 3, 4, 5, 6]
    map1('hello', x => x.toUpperCase());
    // -> ['H', 'E', 'L', 'L', 'O']
  </code></pre>
  <p>
    So we've already written a function that can map <em>any</em> kind of input collection, but it always returns
    an array. This is because the reduction step in our new function amounts to pushing the transformed result
    into an array, a process that remains hard-coded. We could change this reduction step to anything we want to
    &mdash; string concatentation, creating a new immutable list, yielding out of a generator &mdash; but
    whatever we change it to, it'll still be hard-coded. We haven't yet made our reduction generalized. Let's
    look at that next.
  </p>
</section>

<section>
  <h2>Generalized Reduction</h2>
  <p>
    Reduction is a pretty familiar concept to a lot of programmers; in fact, the same <code>Array</code> object
    where <code>map</code> is defined also defines a <code>reduce</code> function. Let's take a look at it in
    action.
  </p>
  <pre><code class="javascript">
    [1, 2, 3, 4, 5].reduce((acc, x) => {
      acc.push(x + 1);
      return acc;
    }, []);
    // -> [2, 3, 4, 5, 6]
  </code></pre>
  <p>
    What this code is doing is...well, it's exactly the same as the first example on this page. It's
    <code>map</code>, defined in terms of <code>reduce</code>. (Interestingly, you can define pretty much any
    list function in terms of <code>reduce</code>, but that's a subject for another time.)
  </p>
  <p>
    The <code>reduce</code> function itself works with three pieces of information: the input collection, a
    <strong>reducer function</strong>, and an <strong>initial value</strong>. The reducer function is what
    actually builds the output collection. It takes two arguments: the current, unfinished output (often called
    the <strong>accumulator</strong>, which is why I name it <code>acc</code>) and the next element of the input
    collection. Its job is to process that element however it needs to and join it with the accumulator to create
    an updated accumulator. Once all of the elements have been processed, that final accumulator is what's
    returned from the <code>reduce</code> function.
  </p>
  <aside>
    <p>
      A <em>reducer function</em> is actually a thing with a specific definition. It is a function that takes an
      accumulator and a new value, and it returns a new accumulator with the new value incorporated. In other
      words, it's a function that's suitable for passing to the <code>reduce</code> list function. We will use
      them quite a bit before the end.
    </p>
  </aside>
  <p>
    The initial value is there because, on the very first invocation of the reducer function, there <em>is no</em>
    accumulator. After all, the function hasn't been run yet to produce one. So on that first go, the initial
    value is sent to the reducer function as the accumulator.
  </p>
  <p>
    Thing is, if you squint just right, you can see both of these new ideas &mdash; a reducer function and an
    initial value &mdash; in our <code>map1</code> function from the last section. Let's look at the function
    again.
  </p>
  <pre><code class="javascript">
    function map1(xs, fn) {
      const result = [];
      for (const x of xs) {
        result.push(fn(x));
      }
      return result;
    }
  </code></pre>
  <p>
    That value that's assigned to <code>result</code> sure does look like an initial value, and the body of the
    <code>for...of</code> loop looks an awful lot like the reduction function. Now that we've identified these
    aspects that are playing a part in reduction, let's see if we can abstract them out.
  </p>
  <pre><code class="javascript">
    function map2(xs, fn, reducer, init) {
      let acc = init;
      for (const x of xs) {
        acc = reducer(acc, fn(x));
      }
      return acc;
    }
  </code></pre>
  <p>
    That looks pretty good. There is nothing hard-coded at all; the reducer function, the initial value, the
    transformer function, and the collection are all passed in as arguments. The <code>for...of</code> loop handles the
    iteration. Inside of it, the <code>reducer</code> function is passed the current accumulator (which is set as the
    initial value the first time through) and the transformed next value in the collection, and it returns a new
    accumulator. When the iteration is complete, the last value of the accumulator is returned as the result. This
    sounds <em>exactly</em> like our <code>reduce</code>-driven mapping above.
  </p>
  <p>
    Let's try it out. Note <code>arrayReducer</code> and <code>stringReducer</code> &mdash; these are perfectly
    normal reducer functions and are not specific to this code. We will use them later, exactly as they're
    presented here.
  </p>
  <pre><code class="javascript">
    function arrayReducer(acc, x) {
      acc.push(x);
      return acc;
    }
    function stringReducer(acc, x) {
      return acc + x;
    }

    map2([1, 2, 3, 4, 5], x => x + 1, arrayReducer, []);
    // -> [2, 3, 4, 5, 6]
    map2('hello', x => x + x, stringReducer, '');
    // -> "hheelllloo"

    // Interesting side effect of separating iteration and
    // reduction: we can iterate differently than we reduce,
    // meaning different input and output collection types
    map2([1, 2, 3, 4, 5], x => x + 1, stringReducer, '');
    // -> "23456"
  </code></pre>
  <p>
    Great! <code>map2</code> looks really nice so far. It <em>only</em> deals with transformation; the
    iteration (via the iteration protocols on the input collection) and the reduction (via the reducer function
    and initial value that we pass to it) are handled by other code that's meant to handle them. What's more, as
    the last example shows, this same function will accept any kind of input collection and produce any kind of
    output collection, <em>even if they're different.</em>. Let's see your list function do that.
  </p>
  <p>
    We're getting a little better idea of transducers now. They have to do with separating a regular list
    function into its single-concern parts so that we have more flexibility in how to call them in order to get
    the transformation we want. But that stuff is all adjectives, describing some characteristics of transducers,
    not telling us what a transducer really <em>is</em>. To get there, we're going to have to look at our third
    problem with list functions &mdash; inefficient composition &mdash; and solve it.
  </p>
</section>

<section>
  <h2>Decomposing composition</h2>
  <p>
    I mentioned earlier that composition is really important for list functions. You wouldn't know it from
    looking at the JavaScript spec &mdash; you won't find a <code>compose</code> function or anything like it in
    there anywhere &mdash; but that doesn't mean we can't work with it ourselves.
  </p>
  <p>
    Let's give an example. This takes <code>Array</code>'s functions <code>map</code> and <code>filter</code>
    and turns them inside out, which makes it more convenient to do composition.
  </p>
  <pre><code class="javascript">
    function arrayMap(fn, xs) {
      return xs => xs.map(fn);
    }
    function arrayFilter(fn, xs) {
      return xs => xs.filter(fn);
    }

    function compose(...fns) {
      return fns.reduce((f, g) => value => f(g(value)));
    }

    let mapAndFilter = compose(arrayMap(x => x + 1), arrayFilter(x => x > 3));
    mapAndFilter([1, 2, 3, 4, 5]);
    // -> [5, 6]
  </code></pre>
  <p>
    This demonstrates a couple of things. First of all, it's convoluted to turn a JavaScript list function into
    an easily composable function, but it can be done. If you had to compose these functions, you'd probaly do it
    with chaining like <a href="https://lodash.com/">Lodash</a> does, but that isn't quite the same and doesn't
    really help us as much with our understanding.
  </p>
  <aside>
    <p>
      If you're really interested in why <code>arrayMap</code> and <code>arrayFilter</code> are coded like they
      are: they're done like this to enable partial function application. If you wanted to actually call
      <code>arrayMap</code>, you would do it like this:
    </p>
    <pre><code class="javascript">
      arrayMap(x => x + 1)([1, 2, 3, 4, 5]);
    </code></pre>
    <p>
      Yes, that's two sets of function parameters. That means that if I choose to only provide the first set of
      arguments, like this:
    </p>
    <pre><code class="javascript">
      arrayMap(x => x + 1);
    </code></pre>
    <p>
      ...then I get back a function that takes a collection and maps it over <code>x => x + 1</code>. This is
      called <strong>partial application</strong>, meaning we provide a function <em>some</em> of the arguments
      it expects, but not <em>all</em> of them. In response, the function returns another function that takes
      the rest of the arguments that we <em>didn't</em> provide. The reason for the unwieldy syntax is that
      JavaScript doesn't actually have partial application, but we can fake it with multiple parameter lists.
    </p>
    <p>
      You can see partial application used in the call to <code>compose</code>. That's because
      <code>compose</code> only wants functions that accept one argument, the collection that they're going to
      work on.
    </p>
    <p>
      Other languages support partial application and make this a lot more natural. We do what we can. You need
      never worry about it again, at least for the rest of this discussion.
    </p>
  </aside>
  <p>
    More importantly, it shows that when you call <code>compose</code>, you get back another function that does
    all of the things that the functions inside the <code>compose</code> call do. This function here is called
    <code>mapAndFilter</code>. You'll notice from the result that <code>arrayFilter</code> must have been called
    first; this right-to-left flow is typical of function composition (and there are good reasons for it).
  </p>
  <p>
    But here's the thing. This is composing list functions. List functions, like we complained about earlier, do
    <em>all</em> the work, including iterating over the input collection and reducing to the output collection.
    This means that when you call <code>mapAndFilter</code>, this is what's happening, in order:
  </p>
  <ol>
    <li><code>arrayFilter</code> breaks the input array into its parts</li>
    <li><code>arrayFilter</code> filters out the parts that aren't greater than 3</li>
    <li><code>arrayFilter</code> puts what's left into a new array</li>
    <li><code>arrayMap</code> breaks the new array into its parts</li>
    <li><code>arrayMap</code> adds 1 to each of these parts</li>
    <li><code>arrayMap</code> puts what's left into another new array</li>
  </ol>
  <p>
    <em>Steps 3 and 4 are completely unnecessary.</em> All they do is put together a new array and immediately
    break it apart again. That's a lot of extra work if those arrays are large, and it multiplies by the number
    of functions that you compose. This is what I meant earlier when I said that composition was inefficient and
    that this was a problem.
  </p>
  <p>
    If we were to compose our current <code>map2</code> function with another similar function, we would suffer
    the same consequences. We will want to do something about this, but we have to think about how to do it.
  </p>
  <p>
    The reason why this isn't easy is because each function needs to know what it's supposed to do depending on
    its context. If <code>map2</code> is called by itself, it needs to iterate over its input and reduce its
    output. But if it's called in a composition pipeline, it only needs to iterate if it's the <em>first</em>
    function in the pipeline, and it only needs to reduce if it's the <em>last</em> function in the pipeline. To
    compose properly, <code>map2</code> needs to know the context in which its called.
  </p>
  <p>
    And this is anathema. We've spent a lot of words already trying to coax a map function into not caring
    about the details of its invocation, into focusing on one thing and one thing alone: transforming values. Now
    we want to ask it to care about the details of its invocation and to care about whether or not to iterate or
    reduce.
  </p>
</section>

<section>
  <h2>Not abstract enough</h2>
  <p>
    The answer, maybe somewhat surprisingly, is that we haven't abstracted iteration and reduction away quite
    enough yet. Sure, the iteration and reduction happens elsewhere, but our <code>map2</code> function is still
    <em>calling</em> that code. The iteration protocol functions are being called by <code>for...of</code>, and
    the <code>reducer</code> function is being called explicitly. And as long as <code>map2</code> is responsible
    for making those calls, it has to be the one to decide whether to make them at all.
  </p>
  <p>
    We don't want to make <code>map2</code> have to understand the context in which it's called so it can figure
    out whether to iterate and whether to reduce. We want it only to accept an input, transform it, and pass it
    along to the next function in the chain. We're going to leave the iteration and reduction to a different
    function, a helper function.
  </p>
  <p>
    So let's give it a try. We're going to write a helper function that will handle when to call the iterator, the
    transformer, and the reducer. To support composition, it will take multiple transformers and call them in order,
    passing the result of one to the input of the next, and then pass the final transformed value to the reducer.
  </p>
  <pre><code class="javascript">
    function map3(fn) {
      return x => fn(x);
    }

    function transform3(xs, xforms, reducer, init) {
      let acc = init;
      for (const x of xs) {
        let value = x;
        for (const xform of xforms) {
          value = xform(value);
        }
        acc = reducer(acc, value);
      }
      return acc;
    }

    // TOLD you we'd use arrayReducer again
    transform3([1, 2, 3, 4, 5], [map(x => x + 1)], arrayReducer, []);
    // -> [2, 3, 4, 5, 6]

    // Works for multiple transformers too
    transform3([1, 2, 3, 4, 5], [map(x => x + 1), map(x => x * 2)], arrayReducer, []);
    // -> [4, 6, 8, 10, 12]
  </code></pre>
  <p>
    Great! Now our transformer is the kind of thing we're looking for &mdash; it takes an input, transforms it, and
    returns the transformed value. It doesn't call the iterator, it doesn't call the reducer &mdash; it doesn't even
    care whether an iterator or reducer exists. It maps. That's all it does.
  </p>
  <p>
    Notice the form of the <code>map3</code> function. It's basically a function that configures and returns
    <em>another</em> function. By doing this pre-loading of the mapping function (<code>fn</code>), we can make sure
    that the helper function can treat every transformer the same: it passes a value to it and expects a value back.
  </p>
  <p>
    Speaking of that helper function &mdash; well, it's not so good, when we look at it closely. In fact it suffers
    from two fatal flaws.
  </p>
  <p>
    One is that this is an ugly way to do composition. The idea is that a composition of more than one function should
    look exactly like another function, just one that does all of the things that all of the functions that it's made
    of does. This doesn't look like a function. It looks like an array of functions.
  </p>
  <p>
    The second problem is that it doesn't really work. Sure, it works fine with this <code>map3</code> function, but
    truth be told, a <code>map</code> function is about the best-behaved transformer function you can have. By its very
    nature, it returns one value for every value that is passed to it. But what if we use a different transformer
    function, one that does <em>not</em> return a value for every value it receives? These are not exotic;
    <code>filter</code> is a function that doesn't always return a value. Let's see how that works.
  </p>
  <pre><code class="javascript">
    function filter3(fn) {
      return x => {
        if (fn(x)) {
          return x;
        }
      };
    }

    transform3([1, 2, 3, 4, 5], [filter(x => x > 3)], arrayReducer, []);
    // -> [undefined, undefined, undefined, 4, 5]
    transform3([1, 2, 3, 4, 5], [map(x => x + 1), filter(x => x > 3)], arrayReducer, []);
    // -> [undefined, undefined, 4, 5, 6]
  </code></pre>
  <p>
    Uh oh! The problem here is prety obvious. The way we've set up <code>transform3</code>, it expects there to be an
    output from the transformer array for each iteration through the input collection. But <code>filter3</code> doesn't
    <em>want</em> to provide a value for every iteration. So on the iterations where no value is provided, we get those
    <code>undefined</code>s contaminating our output
  </p>
</section>

<section>
  <h2>Composition, how does it work?</h2>
  <p>
    So that didn't work, but it did tell us a couple of things that we have to take into consideration to make a
    helper function that <em>does</em> work.
  </p>
  <ol>
    <li>A composed set of functions has to look like a single function.</li>
    <li>If any of the set of composed functions abandons an element, it has to not appear in the output.</li>
  </ol>
  <p>
    We're on the right track with the first requirement. Each transformer does look the same as the next, but now we
    have to make sure that a composed function also looks the same. We can really only do this if the helper function
    only needs to pass in the initial value. To accommodate, we can give the helper function its own helper function
    to make all the rest of the calls.
  </p>
  <pre><code class="javascript">
    function compose4(...xforms) {
      return x => {
        let value = x;
        for (const xform of xforms) {
          value = xform(value);
        }
        return value;
      };
    }

    // Change transform3 to take a single function instead of an array of them
    function transform4(xs, xform, reducer, init) {
      let acc = init;
      for (const x of xs) {
        acc = reducer(acc, xform(x));
      }
      return acc;
    }

    // The other functions stay the same; we'll just rename them so the numbers match
    const map4 = map3;
    const filter4 = filter3;

    let xform = compose4(map4(x => x + 1), filter4(x => x > 3));
    transform4([1, 2, 3, 4, 5], xform, arrayReducer, []);
    // -> [undefined, undefined, 4, 5, 6]
  </code></pre>
  <p>
    Looking good! It seems like our first problem is solved. The <code>compose4</code> function does the same thing as
    our regular transformer functions: it returns a function that takes a value and returns another value. In this
    case, it just calculates the return value by passing it through all of the functions that are composed under it.
    But in the end, this produced function can be passed into our <code>transform4</code> function just like one of
    our regular transformers can do.
  </p>
  <p>
    This does require one nice change to <code>transform3</code>: the new <code>transform4</code> now takes a single
    transformer function, not an array of them. That function can be any function that takes a value and returns
    another value, including the function returned by any of our transformers <em>or</em> the function returned by
    <code>compose4</code>. All looks good.
  </p>
</section>

<section>
  <h2>One down, one to go</h2>
  <p>
    To solve the other problem, getting rid of those nasty <code>undefined</code>s in the output, let's look at what we
    can do with what our transformers' output. Clearly, the way we have it now cannot work &mdash; <code>filter</code>
    would actually have to return <em>nothing at all</em>, not just <code>undefined</code>. There's no way to do that
    in JavaScript. We have to find another way.
  </p>
  <aside>
    <p>
      If that's confusing, understand that <em>every</em> JavaScript function returns a value. If you write a function
      with no <code>return</code> statement, or if you write a bare <code>return;</code> statement that does not
      specify a value to return, then the function helpfully returns <code>undefined</code> without telling you.
    </p>
    <p>
      That's why we get the <code>undefined</code>s in <code>filter4</code>'s output. If a value is filtered out,
      there's no <code>return</code> statement at all to cover that possibilty, so <code>undefined</code> is returned
      instead of returning nothing at all.
    </p>
  </aside>
  <p>
    What we really need is for the transformer to have some measure of control over the reducer. A <code>filter</code>
    function could then fail an input value by simply not invoking the reducer, meaning that there would actually be
    nothing added to the output collection, rather than <code>undefined</code> being added.
  </p>
  <p>
    But we said we didn't want to do that. We said that we don't want the transformer having to decide whether to call
    the reducer. We made an entire helper function to make sure that the transformer didn't even need to know about the
    reducer. We can't go back on our goal after all the work we've put in.
  </p>
  <p>
    But wait...we also decided that we didn't want transformers to do anything but transform, and there they are
    passing their data back and forth to each other. And it's okay, because the transformers still don't know about
    each other &mdash; <code>compose4</code> handles the communication for them. Could we do that with the reducer as
    well, tacking it onto the end of the composition chain like it's just one more transformer? The answer is "yes",
    but there are some changes to be made.
  </p>
  <p>
    As we saw when writing <code>compose4</code>, to do composition correctly, we have to make sure that each function
    takes and returns the same number and kind of values, and we have to make sure that the overall composition does
    the same. A reducer does not take the same number and kind of values as our transformer functions so far. Our
    transformers take a value, while our reducers take an accumulator <em>and</em> a value. We can't change our
    reducer to look like a transformer, but maybe we can change our transformer to look like a reducer.
  </p>
  <p>
    Really, that's an excellent idea. Here's why: <code>compose</code> can be written as a reduction itself. The
    initial value &mdash; in this case, the value being transformed &mdash; is passed to the first function. The
    result becomes the new value, which is passed to the second function. The result becomes the new value...and so on
    and so on, until you run out of functions to pass the ever-changing value to. This is a reduction, pure and simple.
    Just because it's producing a single value &mdash; the completely transformed value &mdash; and not a collection
    does not make it any less a reduction.
  </p>
  <aside>
    <p>
      All of our reductions have been making collections, because making collections is what transducers do. But a
      reducer does not need to produce a collection. Maybe the best example of a reduction is a summing operation.
    </p>
    <pre><code class="java">
      [1, 2, 3, 4, 5].reduce((acc, x) => acc + x, 0);
      // -> 15
    </code></pre>
    <p>
      The reducer function here creates its new value by just adding the total-so-far and the next input, rather than
      appending it to a new collection or something like that. Reduction can be used to make new collections, but
      that's a specific use for it and doesn't represent everything it can do.
    </p>
  </aside>
  <p>
    And here's the last bit of good news: if our <code>filter</code> function becomes a reducer function, it can
    choose to ignore an input element by <em>just returning the original accumulator</em>, rather than returning an
    accumulator with the next element appended to it.
  </p>
  <p>
    So there are our requirements. We have to provide a transformer function that takes the <em>next</em> transformer
    function as an argument and assumes that it's a reducer function. Which means that our function itself needs
    to <em>return</em> a reducer function, so any function earlier in the chain that we pass it to can pretend
    that it is a reducer function itself. Let's try it.
  </p>
  <pre><code class="javascript">
    function map5(fn, next) {
      return (acc, x) => next(acc, fn(x));
    }
  </code></pre>
  <p>
    That's really not so different. Instead of taking a single value and returning a single value, the function that
    this new transformer returns is an actual reducer function. To make this happen, <code>map5</code> needs to take
    one more argument: the next transformer in the chain, which is also assumed to be a reducer function. Suddenly
    it's really easy to tack the reducer onto the end, because it looks just like a transformer too.
  </p>
  <p>
    Of course, this assumes that we have a new helper function that knows to tack the reducer onto the end and knows
    how to call the (possibly composed) transformer function. Let's write that now.
  </p>
  <pre><code class="javascript">
    function transform5(xs, fn, reducer, init) {
      let acc = init;
      const xform = fn(reducer);
      for (const x of xs) {
        acc = xform(acc, x);
      }
      return acc;
    }

    xform = next => map5(x => x + 1, next);
    transform5([1, 2, 3, 4, 5], xform, arrayReducer, []);
    // -> [2, 3, 4, 5, 6]
  </code></pre>
  <p>
    Okay, now that's more like it. Our new <code>transform5</code> function starts by chaining the transformation
    function (<code>fn</code>, which could be a composition of several functions) to the reducer, and then it
    iterates over the input collection, passing each value one at a time to the chain. The accumulator receives
    the output of the reducer function, which is the last link of the chain, and when the iteration completes,
    the accumulator is returned as the output collection.
  </p>
  <p>
    This suggests that a transformer function can be composed with the reducer function, but can multiple
    transformer functions be composed? Let's write a new analogue to our <code>filter4</code> function and use it to
    find out.
  </p>
  <aside>
    <p>
      Jasrt as an aside, even though <code>filter</code> functions don't modify any data they let through, they're
      still transformer functions. They transform collections by retaining some elements and rejecting others.
    </p>
  </aside>
  <pre><code class="javascript">
    function filter5(fn, next) {
      return (acc, x) => fn(x) ? next(acc, x) : acc;
    }

    xform = next => filter5(x => x > 2, map5(x => x + 1, next));
    transform([1, 2, 3, 4, 5], xform, arrayReducer, []);
    // -> [4, 5, 6]
  </code></pre>
  <p>
    It works! Now we have a <code>filter</code> function that simply <em>returns the original accumulator,
    unmodified</em>, when it doesn't want to pass along a value, rather than adding <code>undefined</code> to the
    accumulator and returning it. And since each transformer actually takes the <em>next</em> transformer as an
    argument, we don't even have to use a <code>compose</code> function to make it work. It's almost perfect!
  </p>
  <p>
    What isn't perfect is the syntax. We can see from our <code>transform5</code> function that it wants to chain
    functions together just by passing one to the next, as it does when it passes the reducer function to the
    transformer function. But each of our actual transformer functions accepts <em>two</em> parameters when
    <code>transform5</code> only wants one, meaning that we have to do that ugly thing with the definition of
    <code>xform</code> to create a function that takes only the next transformer function. But there's no reason
    in the world that we can't rewrite our <code>map5</code> and <code>filter5</code> functions to do this for us,
    returning a function that accepts one reducer function and returns another, which is exactly what
    <code>transform5</code> really wants.
  </p>
  <pre><code class="javascript">
    function map(fn) {
      return xform => {
        return (acc, x) => xform(acc, fn(x));
      };
    }

    function filter(fn) {
      return xform => {
        return (acc, x) => fn(x) ? xform(acc, x) : acc;
      };
    }

    function compose(...xforms) {
      const reversed = xforms.reverse();
      return value => reversed.reduce((acc, fn) => fn(acc), value);
    }

    function transduce(xs, xform, reducer, init) {
      const xf = xform(reducer);
      let acc = init;
      for (const x of xs) {
        acc = xf(acc, x);
      }
      return acc;
    }

    xform = compose(map(x => x + 1), filter(x => x > 3);
    transduce([1, 2, 3, 4, 5], xform, arrayReducer, []);
    // -> [4, 5, 6]
  </code></pre>
  <p>
    And there it is. The big change is taking our transformer functions exactly as they are and wrapping them in
    another function which takes the next transformer in the chain. This is exactly the same code as in the prior
    example's definition of <code>xform</code>, just with some better names. Oh, we've done a little housekeeping
    &mdash; we've redefined <code>compose5</code> to create a composition chain by using reduction, because even
    though we've shown we don't <em>need</em> that, it's still a lot nicer to have it than to have to chain our
    functions together by hand. We've also changed the name of the <code>transform5</code> function into something that
    might interest you.
  </p>
  <aside>
    <p>
      In the world of functional programming, composition happens in right-to-left order. There are good reasons for
      this. One of them is that it matches the written order of just applying one function after another by hand:
    </p>
    <pre><code class="javascript">
      comp(f, g)(x) === f(g(x)); // `comp` is taken to be a compose function with 'normal' order
    </code></pre>
    <p>
      Another reason is that reverse order is the natural order when doing composition by reduction, as we're doing in
      our own <code>compose</code> function. However, it's easier to reason about <em>transducer</em> composition if
      it's going left-to-right, mostly because of the step-wise nature of the reduction (and maybe a healthy does of
      personal opinion). This is why our <code>compose</code> function reverses the order of the functions before
      composing them.
    </p>
  </aside>
</section>

<section>
  <h2>Yes, yes...but what is a transducer?</h2>
  <p>
    Time to answer that question once and for all.
  </p>
  <p>
    Take a close look at our final transformer functions, <code>map</code> and <code>filter</code>. They each
    take a reducer function, modify it a little bit by applying a transformation to the value that's being
    reduced at that moment, and return the slightly modified reducer function. It's almost as if what these
    functions are <em>really</em> doing is...<strong>trans</strong>forming re<strong>ducers</strong>. Ooooohhh.
  </p>
  <p>
    So at long last, <strong>transducers are functions that transform reducer functions</strong>, leaving us with
    one big, composed reducer function that does a bunch of transformations right inside. It doesn't care about
    the transducer before it or the one after it &mdash; one of them is ultimately going to be the reducer that
    makes the output collection, but they all look the same to our transducers.
  </p>
  <p>
    Of course, I could have told you in the first paragraph that <em>transducer</em> is a combination of
    <em>transform</em> and <em>reducer</em>, but that wouldn't have told you why transforming reducers is
    important. By making this journey &mdash; which ended up with nothing more than a six-line
    <code>transduce</code> function that handles a bunch of three-line transducers and a utility
    <code>compose</code> function that is standard-issue and can be used to compose <em>any</em> single-argument
    JavaScript functions &mdash; we have learned what transforming reducer functions is good for and, as a side
    effect, solved all of the major problems of list functions.
  </p>
  <ul>
    <li>
      Transducers are single responsibility, concerned only with their job of transforming pieces of data
    </li>
    <li>
      Transducers are loosely coupled, not tied at all to any input or output type, and not even caring what
      happens to the data within composed transducers or even whether there <em>are</em> composed transducers
    </li>
    <li>
      Transducers do not create intermediate collections, only iterating over the input once and reducing only
      to the output once, no matter how many transformations are chained together.
    </li>
  </ul>
  <p>
    This isn't the whole story, of course. Xduce transducers do all of this but have a lot of bells and whistles
    too, like infinite iterators as input or output, reducers read from the output collection instead of
    being passed explicitly to <code>transduce</code>, and explicit iteration (instead of <code>for...of</code>
    loops) that let you iterate over objects in a reasonable way, turn functions into iterators, and all sorts of
    cool things.
  </p>
  <p>
    But at least now you know what a transducer is.
  </p>
</section>

<nav>
  <ul>
    <li><a href="#manual/about/features" title="Xduce features"><span class="fa fa-caret-left"></span></a></li>
    <li><a href="#manual/main" title="Table of contents"><span class="fa fa-caret-up"></span></a></li>
    <li><a href="#manual/setup/commonjs" title="CommonJS setup"><span class="fa fa-caret-right"></a></li>
  </ul>
</nav>
