/*!
 * Copyright (c) 2017 Thomas Otterson
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * 
 */
!(function(t, n) {
  typeof exports == 'object' && typeof module == 'object'
    ? (module.exports = n())
    : typeof define == 'function' && define.amd
      ? define([], n)
      : typeof exports == 'object'
        ? (exports.xduce = n())
        : (t.xduce = n());
})(window, () => {
  return (function(t) {
    const n = {};
    function r(e) {
      if (n[e]) {
        return n[e].exports;
      }
      const i = (n[e] = { i: e, l: !1, exports: {} });
      return t[e].call(i.exports, i, i.exports, r), (i.l = !0), i.exports;
    }
    return (
      (r.m = t),
      (r.c = n),
      (r.d = function(t, n, e) {
        r.o(t, n) || Object.defineProperty(t, n, { enumerable: !0, get: e });
      }),
      (r.r = function(t) {
        typeof Symbol != 'undefined' &&
          Symbol.toStringTag &&
          Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
          Object.defineProperty(t, '__esModule', { value: !0 });
      }),
      (r.t = function(t, n) {
        if ((1 & n && (t = r(t)), 8 & n)) {
          return t;
        }
        if (4 & n && typeof t == 'object' && t && t.__esModule) {
          return t;
        }
        const e = Object.create(null);
        if (
          (r.r(e), Object.defineProperty(e, 'default', { enumerable: !0, value: t }), 2 & n && typeof t != 'string')
        ) {
          for (const i in t) {
            r.d(
              e,
              i,
              (n => {
                return t[n];
              }).bind(null, i)
            );
          }
        }
        return e;
      }),
      (r.n = function(t) {
        const n =
          t && t.__esModule
            ? function() {
                return t.default;
              }
            : function() {
                return t;
              };
        return r.d(n, 'a', n), n;
      }),
      (r.o = function(t, n) {
        return Object.prototype.hasOwnProperty.call(t, n);
      }),
      (r.p = ''),
      r((r.s = 10))
    );
  })([
    function(t, n) {
      t.exports = function(t, n, r) {
        return (
          n in t
            ? Object.defineProperty(t, n, { value: r, enumerable: !0, configurable: !0, writable: !0 })
            : (t[n] = r),
          t
        );
      };
    },
    function(t, n, r) {
      const e = r(11);

      const i = r(12);

      const u = r(13);
      t.exports = function(t, n) {
        return e(t) || i(t, n) || u();
      };
    },
    function(t, n, r) {
      r.r(n),
        function(t) {
          const n = r(1);

          const e = r.n(n);

          const i = Object.prototype.toString;

          const u = Array.isArray;
          t.exports = {
            isArray: u,
            isObject(t) {
              if (i.call(t) !== '[object Object]') {
                return !1;
              }
              const n = Object.getPrototypeOf(t);
              if (n === null) {
                return !0;
              }
              const r = Object.prototype.hasOwnProperty.call(n, 'constructor') && n.constructor;
              return typeof r == 'function' && r === Object;
            },
            isFunction(t) {
              return i.call(t) === '[object Function]';
            },
            isString(t) {
              return i.call(t) === '[object String]';
            },
            isNumber(t) {
              return i.call(t) === '[object Number]' && isFinite(t);
            },
            bmpCharAt(t, n) {
              for (
                var r = t + '', e = n, i = r.length, u = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
                u.exec(r) && u.lastIndex - 2 < e;

              ) {
                e++;
              }
              if (e >= i || e < 0) {
                return '';
              }
              let o = r.charAt(e);
              return /[\uD800-\uDBFF]/.test(o) && /[\uDC00-\uDFFF]/.test(r.charAt(e + 1)) && (o += r.charAt(e + 1)), o;
            },
            bmpLength(t) {
              const n = t + '';

              const r = n.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g);

              const e = r ? r.length : 0;
              return n.length - e;
            },
            range(t, n, r) {
              const i = n == null ? [0, t] : [t, n];

              const u = e()(i, 2);

              const o = u[0];

              const c = u[1];

              const a = r || (o > c ? -1 : 1);
              if (Math.sign(a) !== Math.sign(c - o)) {
                return [o];
              }
              for (var s = [], f = o; a < 0 ? f > c : f < c; f += a) {
                s.push(f);
              }
              return s;
            },
            complement(t) {
              return function() {
                return !t(...arguments);
              };
            }
          };
        }.call(this, r(3)(t));
    },
    function(t, n) {
      t.exports = function(t) {
        if (!t.webpackPolyfill) {
          var n = Object.create(t);
          n.children || (n.children = []),
            Object.defineProperty(n, 'loaded', {
              enumerable: !0,
              get() {
                return n.l;
              }
            }),
            Object.defineProperty(n, 'id', {
              enumerable: !0,
              get() {
                return n.i;
              }
            }),
            Object.defineProperty(n, 'exports', { enumerable: !0 }),
            (n.webpackPolyfill = 1);
        }
        return n;
      };
    },
    function(t, n, r) {
      const e = r(2).isFunction;

      const i = !0;

      const u = typeof Symbol != 'undefined';
      function o(t) {
        return i && u ? Symbol.for(t) : '@@'.concat(t);
      }
      const c = {
        iterator: u ? Symbol.iterator : '@@iterator',
        init: o('transducer/init'),
        step: o('transducer/step'),
        result: o('transducer/result'),
        reduced: o('transducer/reduced'),
        value: o('transducer/value')
      };
      t.exports = {
        protocols: c,
        isImplemented(t, n) {
          if (t == null) {
            return !1;
          }
          switch (n) {
            case 'iterator':
              return e(t[c.iterator] || t.next);
            case 'reduced':
            case 'value':
              return c[n] in t;
            default:
              return e(t[c[n]]);
          }
        }
      };
    },
    function(t, n, r) {
      r.r(n),
        function(t) {
          const n = r(0);

          const e = r.n(n);

          const i = r(4);

          const u = i.protocols;

          const o = i.isImplemented;

          const c = r(8);

          const a = c.isKvFormObject;

          const s = c.iterator;

          const f = r(6);

          const l = f.isCompleted;

          const p = f.reduce;

          const h = f.arrayReducer;

          const d = f.objectReducer;

          const v = f.stringReducer;

          const m = f.toReducer;

          const y = r(2);

          const b = y.isArray;

          const g = y.isObject;

          const x = y.isString;

          const w = y.isFunction;

          const j = u;
          function O(t, n, r, e) {
            const i = w(r) ? m(r) : r;

            const u = void 0 === e ? i[j.init]() : e;

            const o = n ? n(i) : i;
            return p(t, o, u);
          }
          function F(t, n) {
            return O(t, n, h);
          }
          function k(t, n) {
            return O(t, n, d);
          }
          function L(t, n) {
            return O(t, n, v);
          }
          function E(t, n) {
            return n
              ? (function(t, n) {
                  let r;

                  let i;

                  const u = ((r = {}),
                  e()(r, j.step, (t, n) => {
                    const r = a(n) ? e()({}, n.k, n.v) : n;
                    return t.items.unshift(r), t;
                  }),
                  e()(r, j.result, t => {
                    return t;
                  }),
                  r);

                  const o = s(t, null, !0);

                  const c = n(u);

                  let f = !1;
                  return (
                    (i = { items: [] }),
                    e()(i, j.iterator, function() {
                      return this;
                    }),
                    e()(i, 'next', function() {
                      return (
                        this.items.length === 0 && this.step(),
                        this.items.length === 0 ? { done: !0 } : { value: this.items.pop(), done: !1 }
                      );
                    }),
                    e()(i, 'step', function() {
                      for (let t = this.items.length; this.items.length === t; ) {
                        const n = o.next();
                        if (n.done || f) {
                          c[j.result](this);
                          break;
                        }
                        f = l(c[j.step](this, n.value));
                      }
                    }),
                    i
                  );
                })(t, n)
              : s(t);
          }
          t.exports = {
            transduce: O,
            asArray: F,
            asObject: k,
            asString: L,
            asIterator: E,
            sequence(t, n) {
              switch (!0) {
                case b(t):
                  return F(t, n);
                case g(t):
                  return k(t, n);
                case x(t):
                  return L(t, n);
                case o(t, 'step'):
                  return O(t, n, t);
                case o(t, 'iterator'):
                  return E(t, n);
                default:
                  throw Error('Cannot sequence collection: '.concat(t));
              }
            },
            into(t, n, r) {
              switch (!0) {
                case b(t):
                  return O(n, r, h, t);
                case g(t):
                  return O(n, r, d, t);
                case x(t):
                  return O(n, r, v, t);
                case o(t, 'step'):
                  return O(n, r, t, t);
                default:
                  throw Error('Cannot reduce collection into '.concat(t, ': ').concat(n));
              }
            },
            compose() {
              for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++) {
                n[r] = arguments[r];
              }
              const e = n.reverse();
              return function(t) {
                return e.reduce((t, n) => {
                  return n(t);
                }, t);
              };
            }
          };
        }.call(this, r(3)(t));
    },
    function(t, n, r) {
      r.r(n),
        function(t) {
          const n = r(0);

          const e = r.n(n);

          const i = r(2);

          const u = i.isArray;

          const o = i.isFunction;

          const c = i.isObject;

          const a = i.isString;

          const s = r(8);

          const f = s.isKvFormObject;

          const l = s.iterator;

          const p = r(4);

          const h = p.protocols;

          const d = p.isImplemented;

          const v = h;
          function m(t) {
            switch (!0) {
              case d(t, 'init'):
                return t[v.init];
              case a(t):
                return function() {
                  return '';
                };
              case u(t):
                return function() {
                  return [];
                };
              case c(t):
                return function() {
                  return {};
                };
              case o(t):
                return function() {
                  throw Error('init not available');
                };
              default:
                return null;
            }
          }
          function y(t) {
            switch (!0) {
              case d(t, 'step'):
                return t[v.step];
              case a(t):
                return function(t, n) {
                  return t + (f(n) ? n.v : n);
                };
              case u(t):
                return function(t, n) {
                  const r = f(n) ? e()({}, n.k, n.v) : n;
                  return t.push(r), t;
                };
              case c(t):
                return function(t, n) {
                  let r = n;
                  if (f(n)) {
                    r = e()({}, n.k, n.v);
                  } else if (!c(n)) {
                    let i = -1;
                    for (const u in t) {
                      const o = parseInt(u);
                      o > i && (i = o);
                    }
                    r = e()({}, i + 1, n);
                  }
                  for (const a in r) {
                    r.hasOwnProperty(a) && (t[a] = r[a]);
                  }
                  return t;
                };
              case o(t):
                return function(n, r) {
                  return t(n, r);
                };
              default:
                return null;
            }
          }
          function b(t) {
            switch (!0) {
              case d(t, 'result'):
                return t[v.result];
              case a(t):
              case u(t):
              case c(t):
              case o(t):
                return function(t) {
                  return t;
                };
              default:
                return null;
            }
          }
          function g(t) {
            let n;
            return (n = {}), e()(n, v.init, m(t)), e()(n, v.step, y(t)), e()(n, v.result, b(t)), n;
          }
          const x = g([]);

          const w = g({});

          const j = g('');
          function O(t) {
            let n;
            return (n = {}), e()(n, v.reduced, !0), e()(n, v.value, t), n;
          }
          function F(t) {
            if (t != null) {
              return t[v.value];
            }
          }
          function k(t) {
            return t != null && !!t[v.reduced];
          }
          t.exports = {
            init: m,
            step: y,
            result: b,
            toReducer: g,
            arrayReducer: x,
            objectReducer: w,
            stringReducer: j,
            toFunction(t, n) {
              const r = t(typeof n == 'function' ? g(n) : n);
              return r[v.step].bind(r);
            },
            complete: O,
            uncomplete: F,
            isCompleted: k,
            ensureCompleted(t) {
              return k(t) ? t : O(t);
            },
            ensureUncompleted(t) {
              return k(t) ? F(t) : t;
            },
            reduce(t, n, r) {
              if (t == null) {
                return null;
              }
              const e = l(t, null, !0);
              if (!e) {
                throw Error('Cannot reduce an instance of '.concat(t.constructor.name));
              }
              for (var i = r, u = e.next(); !u.done; ) {
                if (k((i = n[v.step](i, u.value)))) {
                  i = F(i);
                  break;
                }
                u = e.next();
              }
              return n[v.result](i);
            }
          };
        }.call(this, r(3)(t));
    },
    function(t, n, r) {
      r.r(n),
        function(t) {
          const n = r(1);

          const e = r.n(n);

          const i = r(0);

          const u = r.n(i);

          const o = r(4).protocols;

          const c = r(5).sequence;

          const a = r(8).isIterable;

          const s = r(2).isNumber;

          const f = r(6);

          const l = f.isCompleted;

          const p = f.complete;

          const h = f.reduce;

          const d = o;
          t.exports = {
            sameValueZero(t, n) {
              return t === n || (isNaN(t) && isNaN(n));
            },
            identity: function t(n) {
              return n
                ? c(n, t())
                : function(t) {
                    return (function(t) {
                      let n;
                      return (
                        (n = {}),
                        u()(n, d.init, () => {
                          return t[d.init]();
                        }),
                        u()(n, d.step, (n, r) => {
                          return t[d.step](n, r);
                        }),
                        u()(n, d.result, n => {
                          return t[d.result](n);
                        }),
                        n
                      );
                    })(t);
                  };
            },
            flatten: function t(n) {
              return n
                ? c(n, t())
                : function(t) {
                    return (function(t) {
                      let n;
                      return (
                        (n = {}),
                        u()(n, d.init, () => {
                          return t[d.init]();
                        }),
                        u()(n, d.step, (n, r) => {
                          let e;

                          const i = ((e = {}),
                          u()(e, d.init, () => {
                            return t[d.init]();
                          }),
                          u()(e, d.step, (n, r) => {
                            const e = t[d.step](n, r);
                            return l(e) ? p(e) : e;
                          }),
                          u()(e, d.result, n => {
                            return t[d.result](n);
                          }),
                          e);
                          return a(r) ? h(r, i, n) : i[d.step](n, r);
                        }),
                        u()(n, d.result, n => {
                          return t[d.result](n);
                        }),
                        n
                      );
                    })(t);
                  };
            },
            repeat: function t(n, r) {
              const i = s(n) ? [null, n] : [n, r];

              const o = e()(i, 2);

              const a = o[0];

              const f = o[1];
              return a
                ? c(a, t(f))
                : function(t) {
                    return (function(t, n) {
                      let r;
                      return (
                        (r = {}),
                        u()(r, d.init, () => {
                          return n[d.init]();
                        }),
                        u()(r, d.step, (r, e) => {
                          for (var i = r, u = 0; u < t && ((i = n[d.step](i, e)), !l(i)); ++u) {}
                          return i;
                        }),
                        u()(r, d.result, t => {
                          return n[d.result](t);
                        }),
                        r
                      );
                    })(f, t);
                  };
            }
          };
        }.call(this, r(3)(t));
    },
    function(t, n, r) {
      r.r(n),
        function(t) {
          const n = r(9);

          const e = r.n(n);

          const i = r(2);

          const u = i.bmpCharAt;

          const o = i.bmpLength;

          const c = i.isArray;

          const a = i.isFunction;

          const s = i.isObject;

          const f = i.isString;

          const l = r(4);

          const p = l.protocols;

          const h = l.isImplemented;

          const d = p;
          t.exports = {
            isKvFormObject(t) {
              const n = Object.keys(t);
              return n.length === 2 && !!~n.indexOf('k') && !!~n.indexOf('v');
            },
            iterator(t, n, r) {
              switch (!0) {
                case a(t[d.iterator]):
                  return t[d.iterator]();
                case a(t.next):
                  return t;
                case a(t):
                  return (function(t) {
                    return e.a.mark(function n() {
                      let r, i;
                      return e.a.wrap(
                        n => {
                          for (;;) {
                            switch ((n.prev = n.next)) {
                              case 0:
                                i = 0;
                              case 1:
                                if (void 0 !== (r = t(i++, r))) {
                                  n.next = 4;
                                  break;
                                }
                                return n.abrupt('break', 8);
                              case 4:
                                return (n.next = 6), r;
                              case 6:
                                n.next = 1;
                                break;
                              case 8:
                              case 'end':
                                return n.stop();
                            }
                          }
                        },
                        n,
                        this
                      );
                    })();
                  })(t);
                case f(t):
                  return (function(t) {
                    let n = 0;
                    return {
                      next() {
                        return n < o(t) ? { value: u(t, n++), done: !1 } : { done: !0 };
                      }
                    };
                  })(t);
                case c(t):
                  return (function(t) {
                    let n = 0;
                    return {
                      next() {
                        return n < t.length ? { value: t[n++], done: !1 } : { done: !0 };
                      }
                    };
                  })(t);
                case s(t):
                  return (function(t, n) {
                    const r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];

                    let e = Object.keys(t);
                    e = typeof n == 'function' ? e.sort(n) : e.sort();
                    let i = 0;
                    return {
                      next() {
                        if (i < e.length) {
                          const n = e[i++];

                          const u = {};
                          return r ? ((u.k = n), (u.v = t[n])) : (u[n] = t[n]), { value: u, done: !1 };
                        }
                        return { done: !0 };
                      }
                    };
                  })(t, n, r);
                default:
                  return null;
              }
            },
            isIterable(t) {
              return h(t, 'iterator') || f(t) || c(t) || s(t);
            }
          };
        }.call(this, r(3)(t));
    },
    function(t, n, r) {
      t.exports = r(14);
    },
    function(t, n, r) {
      const e = r(2);

      const i = e.bmpCharAt;

      const u = e.bmpLength;

      const o = e.range;

      const c = e.complement;

      const a = e.isArray;

      const s = e.isFunction;

      const f = e.isNumber;

      const l = e.isObject;

      const p = e.isString;

      const h = r(6);

      const d = h.complete;

      const v = h.uncomplete;

      const m = h.isCompleted;

      const y = h.ensureCompleted;

      const b = h.ensureUncompleted;

      const g = h.toReducer;

      const x = h.toFunction;

      const w = h.reduce;

      const j = r(4).protocols;

      const O = r(8).iterator;

      const F = r(5);

      const k = F.transduce;

      const L = F.into;

      const E = F.sequence;

      const S = F.asArray;

      const N = F.asIterator;

      const A = F.asObject;

      const _ = F.asString;

      const P = F.compose;

      const q = r(16);

      const R = q.chunk;

      const C = q.chunkBy;

      const I = r(7);

      const B = I.identity;

      const D = I.flatten;

      const W = I.repeat;

      const M = r(17);

      const G = M.distinct;

      const T = M.distinctBy;

      const U = M.distinctWith;

      const V = r(18);

      const Z = V.drop;

      const K = V.dropWhile;

      const Y = r(19);

      const z = Y.filter;

      const H = Y.reject;

      const J = Y.compact;

      const Q = r(20);

      const X = Q.map;

      const $ = Q.flatMap;

      const tt = r(21);

      const nt = tt.take;

      const rt = tt.takeWhile;

      const et = tt.takeNth;

      const it = r(22);

      const ut = it.unique;

      const ot = it.uniqueBy;

      const ct = it.uniqueWith;
      t.exports = {
        util: {
          bmp: { charAt: i, length: u },
          range: o,
          complement: c,
          isArray: a,
          isFunction: s,
          isNumber: f,
          isObject: l,
          isString: p,
          status: { complete: d, uncomplete: v, isCompleted: m, ensureCompleted: y, ensureUncompleted: b }
        },
        protocols: j,
        iterator: O,
        toReducer: g,
        toFunction: x,
        reduce: w,
        transduce: k,
        into: L,
        sequence: E,
        asArray: S,
        asIterator: N,
        asObject: A,
        asString: _,
        compose: P,
        transducers: {
          chunk: R,
          chunkBy: C,
          identity: B,
          flatten: D,
          repeat: W,
          distinct: G,
          distinctBy: T,
          distinctWith: U,
          drop: Z,
          dropWhile: K,
          filter: z,
          reject: H,
          compact: J,
          map: X,
          flatMap: $,
          take: nt,
          takeWhile: rt,
          takeNth: et,
          unique: ut,
          uniqueBy: ot,
          uniqueWith: ct
        }
      };
    },
    function(t, n) {
      t.exports = function(t) {
        if (Array.isArray(t)) {
          return t;
        }
      };
    },
    function(t, n) {
      t.exports = function(t, n) {
        const r = [];

        let e = !0;

        let i = !1;

        let u = void 0;
        try {
          for (
            var o, c = t[Symbol.iterator]();
            !(e = (o = c.next()).done) && (r.push(o.value), !n || r.length !== n);
            e = !0
          ) {}
        } catch (t) {
          (i = !0), (u = t);
        } finally {
          try {
            e || c.return == null || c.return();
          } finally {
            if (i) {
              throw u;
            }
          }
        }
        return r;
      };
    },
    function(t, n) {
      t.exports = function() {
        throw new TypeError('Invalid attempt to destructure non-iterable instance');
      };
    },
    function(t, n, r) {
      const e =
        (function() {
          return this || (typeof self == 'object' && self);
        })() || Function('return this')();

      const i = e.regeneratorRuntime && Object.getOwnPropertyNames(e).indexOf('regeneratorRuntime') >= 0;

      const u = i && e.regeneratorRuntime;
      if (((e.regeneratorRuntime = void 0), (t.exports = r(15)), i)) {
        e.regeneratorRuntime = u;
      } else {
        try {
          delete e.regeneratorRuntime;
        } catch (t) {
          e.regeneratorRuntime = void 0;
        }
      }
    },
    function(t, n) {
      !(function(n) {
        let r;

        const e = Object.prototype;

        const i = e.hasOwnProperty;

        const u = typeof Symbol == 'function' ? Symbol : {};

        const o = u.iterator || '@@iterator';

        const c = u.asyncIterator || '@@asyncIterator';

        const a = u.toStringTag || '@@toStringTag';

        const s = typeof t == 'object';

        let f = n.regeneratorRuntime;
        if (f) {
          s && (t.exports = f);
        } else {
          (f = n.regeneratorRuntime = s ? t.exports : {}).wrap = x;
          var l = 'suspendedStart';

          var p = 'suspendedYield';

          var h = 'executing';

          var d = 'completed';

          var v = {};

          let m = {};
          m[o] = function() {
            return this;
          };
          const y = Object.getPrototypeOf;

          const b = y && y(y(_([])));
          b && b !== e && i.call(b, o) && (m = b);
          const g = (F.prototype = j.prototype = Object.create(m));
          (O.prototype = g.constructor = F),
            (F.constructor = O),
            (F[a] = O.displayName = 'GeneratorFunction'),
            (f.isGeneratorFunction = function(t) {
              const n = typeof t == 'function' && t.constructor;
              return !!n && (n === O || (n.displayName || n.name) === 'GeneratorFunction');
            }),
            (f.mark = function(t) {
              return (
                Object.setPrototypeOf
                  ? Object.setPrototypeOf(t, F)
                  : ((t.__proto__ = F), a in t || (t[a] = 'GeneratorFunction')),
                (t.prototype = Object.create(g)),
                t
              );
            }),
            (f.awrap = function(t) {
              return { __await: t };
            }),
            k(L.prototype),
            (L.prototype[c] = function() {
              return this;
            }),
            (f.AsyncIterator = L),
            (f.async = function(t, n, r, e) {
              const i = new L(x(t, n, r, e));
              return f.isGeneratorFunction(n)
                ? i
                : i.next().then(t => {
                    return t.done ? t.value : i.next();
                  });
            }),
            k(g),
            (g[a] = 'Generator'),
            (g[o] = function() {
              return this;
            }),
            (g.toString = function() {
              return '[object Generator]';
            }),
            (f.keys = function(t) {
              const n = [];
              for (const r in t) {
                n.push(r);
              }
              return (
                n.reverse(),
                function r() {
                  for (; n.length; ) {
                    const e = n.pop();
                    if (e in t) {
                      return (r.value = e), (r.done = !1), r;
                    }
                  }
                  return (r.done = !0), r;
                }
              );
            }),
            (f.values = _),
            (A.prototype = {
              constructor: A,
              reset(t) {
                if (
                  ((this.prev = 0),
                  (this.next = 0),
                  (this.sent = this._sent = r),
                  (this.done = !1),
                  (this.delegate = null),
                  (this.method = 'next'),
                  (this.arg = r),
                  this.tryEntries.forEach(N),
                  !t)
                ) {
                  for (const n in this) {
                    n.charAt(0) === 't' && i.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = r);
                  }
                }
              },
              stop() {
                this.done = !0;
                const t = this.tryEntries[0].completion;
                if (t.type === 'throw') {
                  throw t.arg;
                }
                return this.rval;
              },
              dispatchException(t) {
                if (this.done) {
                  throw t;
                }
                const n = this;
                function e(e, i) {
                  return (c.type = 'throw'), (c.arg = t), (n.next = e), i && ((n.method = 'next'), (n.arg = r)), !!i;
                }
                for (let u = this.tryEntries.length - 1; u >= 0; --u) {
                  const o = this.tryEntries[u];

                  var c = o.completion;
                  if (o.tryLoc === 'root') {
                    return e('end');
                  }
                  if (o.tryLoc <= this.prev) {
                    const a = i.call(o, 'catchLoc');

                    const s = i.call(o, 'finallyLoc');
                    if (a && s) {
                      if (this.prev < o.catchLoc) {
                        return e(o.catchLoc, !0);
                      }
                      if (this.prev < o.finallyLoc) {
                        return e(o.finallyLoc);
                      }
                    } else if (a) {
                      if (this.prev < o.catchLoc) {
                        return e(o.catchLoc, !0);
                      }
                    } else {
                      if (!s) {
                        throw new Error('try statement without catch or finally');
                      }
                      if (this.prev < o.finallyLoc) {
                        return e(o.finallyLoc);
                      }
                    }
                  }
                }
              },
              abrupt(t, n) {
                for (let r = this.tryEntries.length - 1; r >= 0; --r) {
                  const e = this.tryEntries[r];
                  if (e.tryLoc <= this.prev && i.call(e, 'finallyLoc') && this.prev < e.finallyLoc) {
                    var u = e;
                    break;
                  }
                }
                u && (t === 'break' || t === 'continue') && u.tryLoc <= n && n <= u.finallyLoc && (u = null);
                const o = u ? u.completion : {};
                return (
                  (o.type = t),
                  (o.arg = n),
                  u ? ((this.method = 'next'), (this.next = u.finallyLoc), v) : this.complete(o)
                );
              },
              complete(t, n) {
                if (t.type === 'throw') {
                  throw t.arg;
                }
                return (
                  t.type === 'break' || t.type === 'continue'
                    ? (this.next = t.arg)
                    : t.type === 'return'
                      ? ((this.rval = this.arg = t.arg), (this.method = 'return'), (this.next = 'end'))
                      : t.type === 'normal' && n && (this.next = n),
                  v
                );
              },
              finish(t) {
                for (let n = this.tryEntries.length - 1; n >= 0; --n) {
                  const r = this.tryEntries[n];
                  if (r.finallyLoc === t) {
                    return this.complete(r.completion, r.afterLoc), N(r), v;
                  }
                }
              },
              catch(t) {
                for (let n = this.tryEntries.length - 1; n >= 0; --n) {
                  const r = this.tryEntries[n];
                  if (r.tryLoc === t) {
                    const e = r.completion;
                    if (e.type === 'throw') {
                      var i = e.arg;
                      N(r);
                    }
                    return i;
                  }
                }
                throw new Error('illegal catch attempt');
              },
              delegateYield(t, n, e) {
                return (
                  (this.delegate = { iterator: _(t), resultName: n, nextLoc: e }),
                  this.method === 'next' && (this.arg = r),
                  v
                );
              }
            });
        }
        function x(t, n, r, e) {
          const i = n && n.prototype instanceof j ? n : j;

          const u = Object.create(i.prototype);

          const o = new A(e || []);
          return (
            (u._invoke = (function(t, n, r) {
              let e = l;
              return function(i, u) {
                if (e === h) {
                  throw new Error('Generator is already running');
                }
                if (e === d) {
                  if (i === 'throw') {
                    throw u;
                  }
                  return P();
                }
                for (r.method = i, r.arg = u; ; ) {
                  const o = r.delegate;
                  if (o) {
                    const c = E(o, r);
                    if (c) {
                      if (c === v) {
                        continue;
                      }
                      return c;
                    }
                  }
                  if (r.method === 'next') {
                    r.sent = r._sent = r.arg;
                  } else if (r.method === 'throw') {
                    if (e === l) {
                      throw ((e = d), r.arg);
                    }
                    r.dispatchException(r.arg);
                  } else {
                    r.method === 'return' && r.abrupt('return', r.arg);
                  }
                  e = h;
                  const a = w(t, n, r);
                  if (a.type === 'normal') {
                    if (((e = r.done ? d : p), a.arg === v)) {
                      continue;
                    }
                    return { value: a.arg, done: r.done };
                  }
                  a.type === 'throw' && ((e = d), (r.method = 'throw'), (r.arg = a.arg));
                }
              };
            })(t, r, o)),
            u
          );
        }
        function w(t, n, r) {
          try {
            return { type: 'normal', arg: t.call(n, r) };
          } catch (t) {
            return { type: 'throw', arg: t };
          }
        }
        function j() {}
        function O() {}
        function F() {}
        function k(t) {
          ['next', 'throw', 'return'].forEach(n => {
            t[n] = function(t) {
              return this._invoke(n, t);
            };
          });
        }
        function L(t) {
          let n;
          this._invoke = function(r, e) {
            function u() {
              return new Promise((n, u) => {
                !(function n(r, e, u, o) {
                  const c = w(t[r], t, e);
                  if (c.type !== 'throw') {
                    const a = c.arg;

                    const s = a.value;
                    return s && typeof s == 'object' && i.call(s, '__await')
                      ? Promise.resolve(s.__await).then(
                          t => {
                            n('next', t, u, o);
                          },
                          t => {
                            n('throw', t, u, o);
                          }
                        )
                      : Promise.resolve(s).then(
                          t => {
                            (a.value = t), u(a);
                          },
                          t => {
                            return n('throw', t, u, o);
                          }
                        );
                  }
                  o(c.arg);
                })(r, e, n, u);
              });
            }
            return (n = n ? n.then(u, u) : u());
          };
        }
        function E(t, n) {
          const e = t.iterator[n.method];
          if (e === r) {
            if (((n.delegate = null), n.method === 'throw')) {
              if (t.iterator.return && ((n.method = 'return'), (n.arg = r), E(t, n), n.method === 'throw')) {
                return v;
              }
              (n.method = 'throw'), (n.arg = new TypeError("The iterator does not provide a 'throw' method"));
            }
            return v;
          }
          const i = w(e, t.iterator, n.arg);
          if (i.type === 'throw') {
            return (n.method = 'throw'), (n.arg = i.arg), (n.delegate = null), v;
          }
          const u = i.arg;
          return u
            ? u.done
              ? ((n[t.resultName] = u.value),
                (n.next = t.nextLoc),
                n.method !== 'return' && ((n.method = 'next'), (n.arg = r)),
                (n.delegate = null),
                v)
              : u
            : ((n.method = 'throw'),
              (n.arg = new TypeError('iterator result is not an object')),
              (n.delegate = null),
              v);
        }
        function S(t) {
          const n = { tryLoc: t[0] };
          1 in t && (n.catchLoc = t[1]),
            2 in t && ((n.finallyLoc = t[2]), (n.afterLoc = t[3])),
            this.tryEntries.push(n);
        }
        function N(t) {
          const n = t.completion || {};
          (n.type = 'normal'), delete n.arg, (t.completion = n);
        }
        function A(t) {
          (this.tryEntries = [{ tryLoc: 'root' }]), t.forEach(S, this), this.reset(!0);
        }
        function _(t) {
          if (t) {
            const n = t[o];
            if (n) {
              return n.call(t);
            }
            if (typeof t.next == 'function') {
              return t;
            }
            if (!isNaN(t.length)) {
              let e = -1;

              const u = function n() {
                for (; ++e < t.length; ) {
                  if (i.call(t, e)) {
                    return (n.value = t[e]), (n.done = !1), n;
                  }
                }
                return (n.value = r), (n.done = !0), n;
              };
              return (u.next = u);
            }
          }
          return { next: P };
        }
        function P() {
          return { value: r, done: !0 };
        }
      })(
        (function() {
          return this || (typeof self == 'object' && self);
        })() || Function('return this')()
      );
    },
    function(t, n, r) {
      r.r(n),
        function(t) {
          const n = r(1);

          const e = r.n(n);

          const i = r(0);

          const u = r.n(i);

          const o = r(4).protocols;

          const c = r(5).sequence;

          const a = r(6).ensureUncompleted;

          const s = r(2);

          const f = s.isFunction;

          const l = s.isNumber;

          const p = r(7).sameValueZero;

          const h = o;

          const d = Symbol('NO_VALUE');
          t.exports = {
            chunk: function t(n, r) {
              const i = l(n) ? [null, n] : [n, r];

              const o = e()(i, 2);

              const s = o[0];

              const f = o[1];
              return s
                ? c(s, t(f))
                : function(t) {
                    return (function(t, n) {
                      let r;

                      let e = 0;

                      let i = [];
                      return (
                        (r = {}),
                        u()(r, h.init, () => {
                          return n[h.init]();
                        }),
                        u()(r, h.step, (r, u) => {
                          if (((i[e++] = u), e === t)) {
                            const o = i.slice(0, t);
                            return (i = []), (e = 0), n[h.step](r, o);
                          }
                          return r;
                        }),
                        u()(r, h.result, t => {
                          return e > 0 ? a(n[h.step](t, i.slice(0, e))) : n[h.result](t);
                        }),
                        r
                      );
                    })(f, t);
                  };
            },
            chunkBy: function t(n, r, i) {
              const o = f(n) ? [null, n.bind(r)] : [n, r.bind(i)];

              const s = e()(o, 2);

              const l = s[0];

              const v = s[1];
              return l
                ? c(l, t(v))
                : function(t) {
                    return (function(t, n) {
                      let r;

                      let e = [];

                      let i = d;
                      return (
                        (r = {}),
                        u()(r, h.init, () => {
                          return n[h.init]();
                        }),
                        u()(r, h.step, (r, u) => {
                          const o = t(u);

                          let c = r;
                          return i === d || p(o, i) ? e.push(u) : ((c = n[h.step](c, e)), (e = [u])), (i = o), c;
                        }),
                        u()(r, h.result, t => {
                          const r = e.length;
                          return r > 0 ? a(n[h.step](t, e.slice(0, r))) : n[h.result](t);
                        }),
                        r
                      );
                    })(v, t);
                  };
            }
          };
        }.call(this, r(3)(t));
    },
    function(t, n, r) {
      r.r(n),
        function(t) {
          const n = r(1);

          const e = r.n(n);

          const i = r(0);

          const u = r.n(i);

          const o = r(4).protocols;

          const c = r(5).sequence;

          const a = r(2).isFunction;

          const s = r(7).sameValueZero;

          const f = o;

          const l = Symbol('NO_VALUE');
          function p(t, n, r) {
            const i = a(t) ? [null, t.bind(n)] : [t, n.bind(r)];

            const o = e()(i, 2);

            const s = o[0];

            const h = o[1];
            return s
              ? c(s, p(h))
              : function(t) {
                  return (function(t, n) {
                    let r;

                    let e = l;
                    return (
                      (r = {}),
                      u()(r, f.init, () => {
                        return n[f.init]();
                      }),
                      u()(r, f.step, (r, i) => {
                        return e !== l && t(i, e) ? r : ((e = i), n[f.step](r, i));
                      }),
                      u()(r, f.result, t => {
                        return n[f.result](t);
                      }),
                      r
                    );
                  })(h, t);
                };
          }
          t.exports = {
            distinct(t) {
              return p(t, s);
            },
            distinctBy(t, n, r) {
              const i = a(t) ? [null, t.bind(n)] : [t, n.bind(r)];

              const u = e()(i, 2);

              const o = u[0];

              const c = u[1];
              return p(o, (t, n) => {
                return s(c(t), c(n));
              });
            },
            distinctWith: p
          };
        }.call(this, r(3)(t));
    },
    function(t, n, r) {
      r.r(n),
        function(t) {
          const n = r(1);

          const e = r.n(n);

          const i = r(0);

          const u = r.n(i);

          const o = r(4).protocols;

          const c = r(5).sequence;

          const a = r(2);

          const s = a.isNumber;

          const f = a.isFunction;

          const l = o;
          t.exports = {
            drop: function t(n, r) {
              const i = s(n) ? [null, n] : [n, r];

              const o = e()(i, 2);

              const a = o[0];

              const f = o[1];
              return a
                ? c(a, t(f))
                : function(t) {
                    return (function(t, n) {
                      let r;

                      let e = 0;
                      return (
                        (r = {}),
                        u()(r, l.init, () => {
                          return n[l.init]();
                        }),
                        u()(r, l.step, (r, i) => {
                          return e++ < t ? r : n[l.step](r, i);
                        }),
                        u()(r, l.result, t => {
                          return n[l.result](t);
                        }),
                        r
                      );
                    })(f, t);
                  };
            },
            dropWhile: function t(n, r, i) {
              const o = f(n) ? [null, n.bind(r)] : [n, r.bind(i)];

              const a = e()(o, 2);

              const s = a[0];

              const p = a[1];
              return s
                ? c(s, t(p))
                : function(t) {
                    return (function(t, n) {
                      let r;

                      let e = !0;
                      return (
                        (r = {}),
                        u()(r, l.init, () => {
                          return n[l.init]();
                        }),
                        u()(r, l.step, (r, i) => {
                          if (e) {
                            if (t(i)) {
                              return r;
                            }
                            e = !1;
                          }
                          return n[l.step](r, i);
                        }),
                        u()(r, l.result, t => {
                          return n[l.result](t);
                        }),
                        r
                      );
                    })(p, t);
                  };
            }
          };
        }.call(this, r(3)(t));
    },
    function(t, n, r) {
      r.r(n),
        function(t) {
          const n = r(1);

          const e = r.n(n);

          const i = r(0);

          const u = r.n(i);

          const o = r(4).protocols;

          const c = r(5).sequence;

          const a = r(2);

          const s = a.isFunction;

          const f = a.complement;

          const l = o;
          function p(t, n, r) {
            const i = s(t) ? [null, t.bind(n)] : [t, n.bind(r)];

            const o = e()(i, 2);

            const a = o[0];

            const f = o[1];
            return a
              ? c(a, p(f))
              : function(t) {
                  return (function(t, n) {
                    let r;
                    return (
                      (r = {}),
                      u()(r, l.init, () => {
                        return n[l.init]();
                      }),
                      u()(r, l.step, (r, e) => {
                        return t(e) ? n[l.step](r, e) : r;
                      }),
                      u()(r, l.result, t => {
                        return n[l.result](t);
                      }),
                      r
                    );
                  })(f, t);
                };
          }
          t.exports = {
            filter: p,
            reject(t, n, r) {
              const i = s(t) ? [null, t.bind(n)] : [t, n.bind(r)];

              const u = e()(i, 2);

              const o = u[0];

              const c = u[1];
              return p(o, f(c));
            },
            compact(t) {
              return p(t, t => {
                return !!t;
              });
            }
          };
        }.call(this, r(3)(t));
    },
    function(t, n, r) {
      r.r(n),
        function(t) {
          const n = r(1);

          const e = r.n(n);

          const i = r(0);

          const u = r.n(i);

          const o = r(4).protocols;

          const c = r(5);

          const a = c.sequence;

          const s = c.compose;

          const f = r(2).isFunction;

          const l = r(7).flatten;

          const p = o;
          function h(t, n, r) {
            const i = f(t) ? [null, t.bind(n)] : [t, n.bind(r)];

            const o = e()(i, 2);

            const c = o[0];

            const s = o[1];
            return c
              ? a(c, h(s))
              : function(t) {
                  return (function(t, n) {
                    let r;
                    return (
                      (r = {}),
                      u()(r, p.init, () => {
                        return n[p.init]();
                      }),
                      u()(r, p.step, (r, e) => {
                        return n[p.step](r, t(e));
                      }),
                      u()(r, p.result, t => {
                        return n[p.result](t);
                      }),
                      r
                    );
                  })(s, t);
                };
          }
          t.exports = {
            map: h,
            flatMap(t, n, r) {
              const i = f(t) ? [null, t.bind(n)] : [t, n.bind(r)];

              const u = e()(i, 2);

              const o = u[0];

              const c = u[1];
              return o ? a(o, s(h(c), l())) : s(h(c), l());
            }
          };
        }.call(this, r(3)(t));
    },
    function(t, n, r) {
      r.r(n),
        function(t) {
          const n = r(1);

          const e = r.n(n);

          const i = r(0);

          const u = r.n(i);

          const o = r(4).protocols;

          const c = r(6).ensureCompleted;

          const a = r(5).sequence;

          const s = r(2);

          const f = s.isNumber;

          const l = s.isFunction;

          const p = o;
          t.exports = {
            take: function t(n, r) {
              const i = f(n) ? [null, n] : [n, r];

              const o = e()(i, 2);

              const s = o[0];

              const l = o[1];
              return s
                ? a(s, t(l))
                : function(t) {
                    return (function(t, n) {
                      let r;

                      let e = 0;
                      return (
                        (r = {}),
                        u()(r, p.init, () => {
                          return n[p.init]();
                        }),
                        u()(r, p.step, (r, i) => {
                          let u = r;
                          return e < t && ((u = n[p.step](r, i)), e === t - 1 && (u = c(u))), e++, u;
                        }),
                        u()(r, p.result, t => {
                          return n[p.result](t);
                        }),
                        r
                      );
                    })(l, t);
                  };
            },
            takeWhile: function t(n, r, i) {
              const o = l(n) ? [null, n.bind(r)] : [n, r.bind(i)];

              const s = e()(o, 2);

              const f = s[0];

              const h = s[1];
              return f
                ? a(f, t(h))
                : function(t) {
                    return (function(t, n) {
                      let r;
                      return (
                        (r = {}),
                        u()(r, p.init, () => {
                          return n[p.init]();
                        }),
                        u()(r, p.step, (r, e) => {
                          return t(e) ? n[p.step](r, e) : c(r);
                        }),
                        u()(r, p.result, t => {
                          return n[p.result](t);
                        }),
                        r
                      );
                    })(h, t);
                  };
            },
            takeNth: function t(n, r) {
              const i = f(n) ? [null, n] : [n, r];

              const o = e()(i, 2);

              const c = o[0];

              const s = o[1];
              return c
                ? a(c, t(s))
                : function(t) {
                    return (function(t, n) {
                      let r;

                      let e = -1;
                      return (
                        (r = {}),
                        u()(r, p.init, () => {
                          return n[p.init]();
                        }),
                        u()(r, p.step, (r, i) => {
                          return ++e % t == 0 ? n[p.step](r, i) : r;
                        }),
                        u()(r, p.result, t => {
                          return n[p.result](t);
                        }),
                        r
                      );
                    })(s, t);
                  };
            }
          };
        }.call(this, r(3)(t));
    },
    function(t, n, r) {
      r.r(n),
        function(t) {
          const n = r(1);

          const e = r.n(n);

          const i = r(0);

          const u = r.n(i);

          const o = r(4).protocols;

          const c = r(5).sequence;

          const a = r(2).isFunction;

          const s = r(7).sameValueZero;

          const f = o;
          function l(t, n, r) {
            const i = a(t) ? [null, t.bind(n)] : [t, n.bind(r)];

            const o = e()(i, 2);

            const s = o[0];

            const p = o[1];
            return s
              ? c(s, l(p))
              : function(t) {
                  return (function(t, n) {
                    let r;

                    const e = [];
                    return (
                      (r = {}),
                      u()(r, f.init, () => {
                        return n[f.init]();
                      }),
                      u()(r, f.step, (r, i) => {
                        return e.some(n => {
                          return t(i, n);
                        })
                          ? r
                          : (e.push(i), n[f.step](r, i));
                      }),
                      u()(r, f.result, t => {
                        return n[f.result](t);
                      }),
                      r
                    );
                  })(p, t);
                };
          }
          t.exports = {
            unique(t) {
              return l(t, s);
            },
            uniqueBy(t, n, r) {
              const i = a(t) ? [null, t.bind(n)] : [t, n.bind(r)];

              const u = e()(i, 2);

              const o = u[0];

              const c = u[1];
              return l(o, (t, n) => {
                return s(c(t), c(n));
              });
            },
            uniqueWith: l
          };
        }.call(this, r(3)(t));
    }
  ]);
});
